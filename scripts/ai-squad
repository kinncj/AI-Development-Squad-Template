#!/usr/bin/env bash
# ai-squad — AI Development Squad CLI
#
# Install globally:
#   git clone https://github.com/kinncj/AI-Development-Squad-Template.git ~/.ai-squad
#   echo 'export PATH="$HOME/.ai-squad/scripts:$PATH"' >> ~/.zshrc
#   source ~/.zshrc
#
# Usage:
#   ai-squad init          [project-name]          Scaffold template into new or current directory
#   ai-squad labels        [owner/repo]             Create GitHub labels in current repo
#   ai-squad swarm                                  Open interactive orchestrator chat (Claude Code only)
#   ai-squad swarm feature "<description>"          Non-interactive shortcut with pre-loaded description
#   ai-squad swarm full                             Launch all plan tasks in parallel Zellij tabs
#   ai-squad swarm tasks   <n> [n...]               Launch specific task numbers
#   ai-squad swarm agent   <@name> <prompt>         Run a single named agent
#   ai-squad swarm status  [session-id]             Show agent status table
#   ai-squad swarm merge   [session-id]             Merge completed agent branches
#   ai-squad help                                   Show this help
#
# Copyright (C) 2025 Kinn Coelho Juliao <kinncj@protonmail.com>
# SPDX-License-Identifier: AGPL-3.0-or-later
set -euo pipefail

TOOL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
TEMPLATE_DIR="$TOOL_DIR/template"
SCRIPTS_DIR="$TOOL_DIR/scripts"
PLAN_FILE="${PLAN_FILE:-docs/specs/current/plan.md}"
GLOBAL_CONFIG="$HOME/.ai-squad.json"   # jingle state — once ever, across all projects
CONFIG_FILE="$(pwd)/.ai-squad.json"    # project options — per working directory

# ─── Colour palette ───────────────────────────────────────────────────────────
if [[ -n "${NO_COLOR:-}" || "${TERM:-}" == "dumb" || ! -t 1 ]]; then
  R=''; B=''; D=''; GRN=''; YLW=''; CYN=''
  BGRN=''; BRED=''; BYEL=''; BCYN=''; BMGT=''
  HGRN=''  # hacker green (for banner)
else
  R='\033[0m';    B='\033[1m';    D='\033[2m'
  GRN='\033[0;32m';  YLW='\033[0;33m';  CYN='\033[0;36m'
  BGRN='\033[1;32m'; BRED='\033[1;31m'; BYEL='\033[1;33m'
  BCYN='\033[1;36m'; BMGT='\033[1;35m'
  HGRN='\033[0;32m'  # hacker green
fi

HR="  ${D}$(printf '─%.0s' {1..60})${R}"

# ─── ASCII banner ─────────────────────────────────────────────────────────────
_BANNER_ROWS=(
  "                                                                    "
  "   ▄▄▄▄   ▄▄▄▄▄    ▄▄▄▄▄▄▄   ▄▄▄▄▄   ▄▄▄  ▄▄▄   ▄▄▄▄   ▄▄▄▄▄▄   "
  "  ▄██▀▀██▄  ███    █████▀▀▀ ▄███████▄ ███  ███ ▄██▀▀██▄ ███▀▀██▄  "
  "  ███  ███  ███     ▀████▄  ███   ███ ███  ███ ███  ███ ███  ███   "
  "  ███▀▀███  ███       ▀████ ███▄█▄███ ███▄▄███ ███▀▀███ ███  ███   "
  "  ███  ███ ▄███▄   ███████▀  ▀█████▀  ▀██████▀ ███  ███ ██████▀   "
  "                          ▀▀                                        "
  "                                                                    "
)
_BANNER_DONE=''

banner() {
  [[ -z "$HGRN" ]] && return

  local N=${#_BANNER_ROWS[@]}  # 8 rows total

  # Subsequent calls (e.g. swarm help after init): print statically, no re-animation
  if [[ -n "$_BANNER_DONE" ]]; then
    printf '%b' "${HGRN}"
    local _r; for _r in "${_BANNER_ROWS[@]}"; do printf '%s\n' "$_r"; done
    printf '%b' "${R}"
    return
  fi
  _BANNER_DONE=1

  # Reserve vertical space for the animation area
  local _i; for ((_i=0; _i<N; _i++)); do printf '\n'; done

  # ── Frame 0: edge-on ─────────────────────────────────────────────────────
  # Single dim line at mid-height simulates the card seen edge-on.
  printf '\033[%dA' "${N}"
  for ((_i=0; _i<N; _i++)); do
    if ((_i == 3)); then
      printf '\033[2K%b\n' \
        "${D}  ──────────────────────────────────────────────────────────────────${R}"
    else
      printf '\033[2K\n'
    fi
  done
  sleep 0.06

  # ── Frames 1-3: expand from center outward ────────────────────────────────
  # Content rows live at indices 1-6.  Center pair: rows 3-4.
  # f=2 → show 2 rows (3-4); f=1 → show 4 rows (2-5); f=0 → show 6 rows (1-6).
  local _f _top _rows
  for _f in 2 1 0; do
    _top=$((_f + 1))        # first visible content index
    _rows=$((6 - 2 * _f))  # rows to reveal: 2, 4, 6
    printf '\033[%dA' "${N}"
    printf '%b' "${HGRN}"
    for ((_i=0; _i<N; _i++)); do
      if ((_i >= _top && _i < _top + _rows)); then
        printf '\033[2K%s\n' "${_BANNER_ROWS[$_i]}"
      else
        printf '\033[2K\n'
      fi
    done
    sleep 0.07
  done

  printf '%b' "${R}"
}

# ─── UI primitives ────────────────────────────────────────────────────────────
header() {
  banner
  printf "  ${B}${BMGT}AI Development Squad${R}  ${D}·${R}  ${B}%s${R}\n" "$1"
  printf "%b\n\n" "$HR"
}

step()    { printf "\n  ${BCYN}›${R}  ${B}%s${R}\n" "$1"; }
ok()      { printf "  ${BGRN}✓${R}  %-32s  ${D}%s${R}\n" "$1" "${2:-}"; }
info()    { printf "  ${CYN}›${R}  %-16s${B}%s${R}\n" "$1" "${2:-}"; }
warn()    { printf "  ${BYEL}!${R}  ${YLW}%s${R}\n" "$1"; }
missing() { printf "  ${BYEL}?${R}  %-32s  ${YLW}not found — %s${R}\n" "$1" "$2"; }
fail()    { printf "\n  ${BRED}✗${R}  ${B}%b${R}\n\n" "$*" >&2; exit 1; }

task_row() {
  local n="$1" agent="$2" desc="$3"
  printf "  ${D}[%2d]${R}  ${BCYN}%-22s${R}  %s\n" "$n" "$agent" "$desc"
}

session_info() {
  printf "\n%b\n" "$HR"
  printf '%b\n' "  ${D}›  Detach   Ctrl-o d${R}"
  printf '%b\n' "  ${D}›  Nav      Alt-n (next tab)  ·  Alt-p (prev tab)${R}"
  printf '%b\n' "  ${D}›  List     zellij list-sessions${R}"
  printf '%b\n' "  ${D}›  Kill     zellij kill-session <name>  (from outside Zellij)${R}"
  printf "%b\n\n" "$HR"
}

# ─── Config & jingle ──────────────────────────────────────────────────────────
_config_init() {
  command -v python3 &>/dev/null || return 0
  # Global config — tracks jingle state
  if [[ ! -f "$GLOBAL_CONFIG" ]]; then
    python3 - "$GLOBAL_CONFIG" <<'PYEOF'
import json, sys
with open(sys.argv[1], "w") as f:
    json.dump({"jingle_played": False}, f, indent=2)
    f.write("\n")
PYEOF
  fi
  # Project config — tracks last-used options for this working directory
  if [[ ! -f "$CONFIG_FILE" ]]; then
    python3 - "$CONFIG_FILE" <<'PYEOF'
import json, sys
with open(sys.argv[1], "w") as f:
    json.dump({"init": {}, "labels": {}, "swarm": {}}, f, indent=2)
    f.write("\n")
PYEOF
  fi
}

_config_set() {
  # _config_set <dot.key> <value>
  # JSON literals (true/false/arrays/numbers) are preserved; bare strings stored as-is.
  command -v python3 &>/dev/null || return 0
  [[ -f "$CONFIG_FILE" ]] || return 0
  python3 - "$CONFIG_FILE" "$1" "$2" <<'PYEOF'
import json, sys
path, dotkey, raw = sys.argv[1], sys.argv[2], sys.argv[3]
try:
    with open(path) as f:
        cfg = json.load(f)
except Exception:
    cfg = {}
keys = dotkey.split(".")
d = cfg
for k in keys[:-1]:
    d = d.setdefault(k, {})
try:
    d[keys[-1]] = json.loads(raw)
except Exception:
    d[keys[-1]] = raw
with open(path, "w") as f:
    json.dump(cfg, f, indent=2)
    f.write("\n")
PYEOF
}

_config_get() {
  command -v python3 &>/dev/null || { echo ""; return 0; }
  [[ -f "$CONFIG_FILE" ]] || { echo ""; return 0; }
  python3 - "$CONFIG_FILE" "$1" <<'PYEOF'
import json, sys
try:
    with open(sys.argv[1]) as f:
        v = json.load(f)
    for k in sys.argv[2].split("."):
        v = v[k]
    print(json.dumps(v) if not isinstance(v, str) else v)
except Exception:
    print("")
PYEOF
}

# Read one key from the global config (jingle state lives here).
# Called via $() so heredoc must NOT be used inline — logic lives in the function body.
_global_config_get() {
  command -v python3 &>/dev/null || { echo ""; return 0; }
  [[ -f "$GLOBAL_CONFIG" ]] || { echo ""; return 0; }
  python3 - "$GLOBAL_CONFIG" "$1" <<'PYEOF'
import json, sys
try:
    with open(sys.argv[1]) as f:
        v = json.load(f)
    for k in sys.argv[2].split("."):
        v = v[k]
    print(json.dumps(v) if not isinstance(v, str) else v)
except Exception:
    print("")
PYEOF
}

_global_config_set() {
  command -v python3 &>/dev/null || return 0
  [[ -f "$GLOBAL_CONFIG" ]] || return 0
  python3 - "$GLOBAL_CONFIG" "$1" "$2" <<'PYEOF'
import json, sys
path, dotkey, raw = sys.argv[1], sys.argv[2], sys.argv[3]
try:
    with open(path) as f:
        cfg = json.load(f)
except Exception:
    cfg = {}
keys = dotkey.split(".")
d = cfg
for k in keys[:-1]:
    d = d.setdefault(k, {})
try:
    d[keys[-1]] = json.loads(raw)
except Exception:
    d[keys[-1]] = raw
with open(path, "w") as f:
    json.dump(cfg, f, indent=2)
    f.write("\n")
PYEOF
}

_play_jingle() {
  local jingle="$TOOL_DIR/AI_SQUAD_JINGLE.wav"
  [[ -f "$jingle" ]] || return 0
  [[ "$(_global_config_get jingle_played)" == "true" ]] && return 0
  _global_config_set "jingle_played" "true"   # mark before playing (fire-and-forget)
  # Launch audio in background. Never crash — all errors are silently swallowed.
  {
    if command -v afplay &>/dev/null; then
      # macOS — afplay only handles PCM WAV; use Python3 to unwrap MP3-in-RIFF if needed
      python3 - "$jingle" <<'PYEOF'
import sys, struct, tempfile, os, subprocess

path = sys.argv[1]
with open(path, 'rb') as f:
    data = f.read()

play_path = path
tmp = None

if data[:4] == b'RIFF' and data[8:12] == b'WAVE':
    i = 12
    while i < len(data) - 8:
        cid = data[i:i+4]
        csz = struct.unpack_from('<I', data, i+4)[0]
        if cid == b'data':
            raw = data[i+8:i+8+csz]
            # MP3 sync: ID3 tag or 0xFF 0xEx/0xFF 0xFx frame header
            if raw[:3] == b'ID3' or (len(raw) > 1 and raw[0] == 0xFF and raw[1] & 0xE0 == 0xE0):
                tmp = tempfile.NamedTemporaryFile(suffix='.mp3', delete=False)
                tmp.write(raw)
                tmp.close()
                play_path = tmp.name
            break
        i += 8 + max(csz, 1)

try:
    subprocess.run(['afplay', play_path],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
finally:
    if tmp:
        os.unlink(tmp.name)
PYEOF
    elif command -v paplay         &>/dev/null; then
      # Linux — PulseAudio / PipeWire
      paplay "$jingle"
    elif command -v aplay          &>/dev/null; then
      # Linux — ALSA
      aplay -q "$jingle"
    elif command -v powershell.exe &>/dev/null; then
      # Windows — Git Bash / WSL boundary
      local _win_path
      _win_path="$(command -v cygpath &>/dev/null && cygpath -w "$jingle" 2>/dev/null || echo "$jingle")"
      powershell.exe -NoProfile -Command \
        "(New-Object Media.SoundPlayer '$_win_path').PlaySync()"
    fi
  } >/dev/null 2>&1 &
}

# ─── OpenCode model configuration ─────────────────────────────────────────────
_oc_replace_in_file() {
  # _oc_replace_in_file <file> <from> <to>
  command -v python3 &>/dev/null || return 0
  [[ -f "$1" ]] || return 0
  python3 - "$1" "$2" "$3" <<'PYEOF'
import sys
path, old, new = sys.argv[1], sys.argv[2], sys.argv[3]
with open(path) as f:
    content = f.read()
if old in content:
    with open(path, 'w') as f:
        f.write(content.replace(old, new))
PYEOF
}

_oc_replace_all() {
  # _oc_replace_all <agents-dir> <opencode-json> <from> <to>
  local dir="$1" json="$2" from="$3" to="$4"
  for f in "$dir"/*.md; do
    [[ -f "$f" ]] && _oc_replace_in_file "$f" "$from" "$to"
  done
  [[ -f "$json" ]] && _oc_replace_in_file "$json" "$from" "$to"
}

_configure_opencode_models() {
  local TARGET="$1"
  local AGENTS_DIR="$TARGET/.opencode/agents"
  local OC_JSON="$TARGET/opencode.json"

  [[ -d "$AGENTS_DIR" ]] || return 0

  step "Configuring OpenCode model providers"

  local HAS_ANTHROPIC='' HAS_COPILOT=''

  printf '%b' "  ${CYN}?${R}  Do you have a ${B}Claude Code${R} (Anthropic API) account? [y/N] "
  read -r _ans
  [[ "$_ans" =~ ^[Yy]$ ]] && HAS_ANTHROPIC=1

  printf '%b' "  ${CYN}?${R}  Do you have a ${B}GitHub Copilot${R} account? [y/N] "
  read -r _ans
  [[ "$_ans" =~ ^[Yy]$ ]] && HAS_COPILOT=1

  local COPILOT_SONNET="claude-sonnet-4.5"
  local COPILOT_OPUS="claude-opus-4.5"

  if [[ -n "$HAS_COPILOT" ]]; then
    printf '%b' "  ${CYN}?${R}  Do you have access to ${B}Claude Sonnet 4.6${R} in GitHub Copilot? [y/N] "
    read -r _ans
    [[ "$_ans" =~ ^[Yy]$ ]] && COPILOT_SONNET="claude-sonnet-4.6"

    printf '%b' "  ${CYN}?${R}  Do you have access to ${B}Claude Opus 4.6${R} in GitHub Copilot? [y/N] "
    read -r _ans
    [[ "$_ans" =~ ^[Yy]$ ]] && COPILOT_OPUS="claude-opus-4.6"
  fi

  local _provider

  if [[ -n "$HAS_ANTHROPIC" && -n "$HAS_COPILOT" ]]; then
    # Both: keep anthropic defaults for orchestration; upgrade copilot impl models if available
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-sonnet-4.5" "github-copilot/${COPILOT_SONNET}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-opus-4.5"   "github-copilot/${COPILOT_OPUS}"
    ok "Both providers" "anthropic/* orchestration · github-copilot/${COPILOT_SONNET} implementation"
    _provider="both"

  elif [[ -n "$HAS_ANTHROPIC" ]]; then
    # Anthropic API only — route everything through anthropic/
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-sonnet-4.5" "anthropic/claude-sonnet-4-6"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-opus-4.5"   "anthropic/claude-opus-4-6"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "copilot/gpt-4.1"                  "anthropic/claude-sonnet-4-6"
    ok "Anthropic only" "anthropic/claude-opus-4-6 · anthropic/claude-sonnet-4-6"
    _provider="anthropic"

  elif [[ -n "$HAS_COPILOT" ]]; then
    # GitHub Copilot only — route everything through github-copilot/
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "anthropic/claude-opus-4-6"        "github-copilot/${COPILOT_OPUS}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "anthropic/claude-sonnet-4-6"      "github-copilot/${COPILOT_SONNET}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-sonnet-4.5" "github-copilot/${COPILOT_SONNET}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-opus-4.5"   "github-copilot/${COPILOT_OPUS}"
    ok "GitHub Copilot only" "github-copilot/${COPILOT_OPUS} · github-copilot/${COPILOT_SONNET}"
    _provider="copilot"

  else
    # No commercial subscription — offer free/local alternatives
    printf '\n'
    warn "No provider selected. The squad needs at least one model provider."
    printf '\n'
    printf '%b\n' "  ${BCYN}Free cloud models${R}  ${D}(require an opencode provider connection)${R}"
    printf '%b\n' "  ${D}[1]${R}  opencode/big-pickle"
    printf '%b\n' "  ${D}[2]${R}  opencode/glm-5-free"
    printf '%b\n' "  ${D}[3]${R}  opencode/gpt-5-nano"
    printf '%b\n' "  ${D}[4]${R}  opencode/kimi-k2.5-free"
    printf '%b\n' "  ${D}[5]${R}  opencode/minimax-m2.5-free"
    printf '%b\n' "  ${BCYN}Local models${R}  ${D}(require Ollama running locally)${R}"
    printf '%b\n' "  ${D}[6]${R}  ollama/llama3.2:latest"
    printf '%b\n' "  ${D}[7]${R}  Custom Ollama model ID"
    printf '%b\n' "  ${D}[8]${R}  Skip — configure manually later"
    printf '\n'

    local BIG_MODEL FAST_MODEL _pick

    printf '%b' "  ${CYN}?${R}  ${B}Big model${R}  ${D}(orchestrator, architect — heavy reasoning)${R} [1-8]: "
    read -r _pick
    case "$_pick" in
      1) BIG_MODEL="opencode/big-pickle" ;;
      2) BIG_MODEL="opencode/glm-5-free" ;;
      3) BIG_MODEL="opencode/gpt-5-nano" ;;
      4) BIG_MODEL="opencode/kimi-k2.5-free" ;;
      5) BIG_MODEL="opencode/minimax-m2.5-free" ;;
      6) BIG_MODEL="ollama/llama3.2:latest" ;;
      7)
        printf '%b' "  ${CYN}?${R}  Custom Ollama model (e.g. ollama/mistral:latest): "
        read -r BIG_MODEL
        ;;
      *) BIG_MODEL="" ;;
    esac

    printf '%b' "  ${CYN}?${R}  ${B}Fast model${R}  ${D}(all implementation agents)${R} [1-8]: "
    read -r _pick
    case "$_pick" in
      1) FAST_MODEL="opencode/big-pickle" ;;
      2) FAST_MODEL="opencode/glm-5-free" ;;
      3) FAST_MODEL="opencode/gpt-5-nano" ;;
      4) FAST_MODEL="opencode/kimi-k2.5-free" ;;
      5) FAST_MODEL="opencode/minimax-m2.5-free" ;;
      6) FAST_MODEL="ollama/llama3.2:latest" ;;
      7)
        printf '%b' "  ${CYN}?${R}  Custom Ollama model (e.g. ollama/mistral:latest): "
        read -r FAST_MODEL
        ;;
      *) FAST_MODEL="" ;;
    esac

    if [[ -z "$BIG_MODEL" || -z "$FAST_MODEL" ]]; then
      warn "Skipping model configuration — edit .opencode/agents/*.md manually."
      _provider="manual"
    else
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "anthropic/claude-opus-4-6"        "$BIG_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "github-copilot/claude-opus-4.5"   "$BIG_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "anthropic/claude-sonnet-4-6"      "$FAST_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "github-copilot/claude-sonnet-4.5" "$FAST_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "copilot/gpt-4.1"                  "$FAST_MODEL"
      ok "Models configured" "${BIG_MODEL} · ${FAST_MODEL}"
      _provider="free"

      # Provider connection instructions
      printf '\n%b\n' "$HR"
      printf '%b\n' "  ${BYEL}!${R}  ${B}Action required: connect providers in OpenCode${R}"
      printf '\n'
      if [[ "$BIG_MODEL" == opencode/* || "$FAST_MODEL" == opencode/* ]]; then
        printf '%b\n' "  ${BCYN}opencode/* models${R} — add the opencode provider:"
        printf '%b\n' "  ${D}  opencode → Settings → Providers → opencode${R}"
        printf '%b\n' "  ${D}  Get your API key at https://opencode.ai${R}"
        printf '\n'
      fi
      if [[ "$BIG_MODEL" == ollama/* || "$FAST_MODEL" == ollama/* ]]; then
        local _ollama_model
        _ollama_model=$(printf '%s\n%s\n' "$BIG_MODEL" "$FAST_MODEL" \
          | grep '^ollama/' | sed 's|ollama/||' | head -1)
        printf '%b\n' "  ${BCYN}ollama/* models${R} — start Ollama and pull the model:"
        printf '%b\n' "  ${D}  brew install ollama && ollama serve${R}"
        printf '%b  ollama pull %s%b\n' "$D" "$_ollama_model" "$R"
        printf '%b\n' "  ${D}  opencode → Settings → Providers → Ollama (http://localhost:11434)${R}"
        printf '\n'
      fi
      printf '%b\n' "$HR"
    fi
  fi

  _config_set "init.opencode_provider" "${_provider:-unknown}"
}

# ─── init ─────────────────────────────────────────────────────────────────────
cmd_init() {
  local TARGET_DIR ASSUME_YES=''

  # Parse flags before positional argument
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --yes|-y) ASSUME_YES=1; shift ;;
      --) shift; break ;;
      -*) fail "Unknown flag: $1" ;;
      *) break ;;
    esac
  done

  if [[ $# -gt 0 ]]; then
    if [[ "$1" = /* ]]; then
      TARGET_DIR="$1"
    else
      TARGET_DIR="$(pwd)/$1"
    fi
  else
    TARGET_DIR="$(pwd)"
  fi

  header "Initialize Project"
  info "Template" "$TEMPLATE_DIR"
  info "Target  " "$TARGET_DIR"

  if [[ -d "$TARGET_DIR" ]] && [[ -n "$(ls -A "$TARGET_DIR" 2>/dev/null)" ]]; then
    warn "Directory is not empty: $TARGET_DIR"
    if [[ -n "$ASSUME_YES" ]]; then
      warn "Proceeding (--yes)"
    else
      printf '%b' "  ${BYEL}?${R}  Existing files may be overwritten. Continue? [y/N] "
      read -r _ans
      [[ "$_ans" =~ ^[Yy]$ ]] || fail "Aborted."
    fi
  fi

  mkdir -p "$TARGET_DIR"

  step "Checking dependencies"
  local cmd install
  while IFS=: read -r cmd install; do
    if command -v "$cmd" &>/dev/null; then
      ok "$cmd" "$(command -v "$cmd")"
    else
      missing "$cmd" "$install"
    fi
  done <<'DEPS'
git:https://git-scm.com
gh:brew install gh
docker:https://docker.com
node:https://nodejs.org
claude:npm install -g @anthropic-ai/claude-code
DEPS

  step "Copying template"
  rsync -a \
    --exclude='.git' \
    --exclude='node_modules' \
    --exclude='*.log' \
    "$TEMPLATE_DIR/" "$TARGET_DIR/"
  local FILE_COUNT
  FILE_COUNT=$(find "$TARGET_DIR" -type f | wc -l | tr -d ' ')
  ok "Files copied" "$FILE_COUNT files"

  printf "\n%b\n" "$HR"
  if [[ -z "$ASSUME_YES" ]]; then
    _configure_opencode_models "$TARGET_DIR"
  fi

  step "Initializing git repository"
  cd "$TARGET_DIR"
  git init -q
  git add -A
  git commit -q -m "chore: initialize from AI Development Squad Template

Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
Source:    $(basename "$TOOL_DIR")"
  ok "Repository initialized" "commit $(git rev-parse --short HEAD)"
  _config_set "init.last_project" "$(basename "$TARGET_DIR")"
  _config_set "init.last_target"  "$TARGET_DIR"
  _config_set "init.last_run"     "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  if [[ -f "package.json" ]]; then
    step "Installing dependencies"
    npm install --silent
    ok "npm dependencies installed"
    if npx playwright install chromium --quiet 2>/dev/null; then
      ok "Playwright browsers installed"
    else
      warn "Playwright install failed — run: npx playwright install"
    fi
  fi

  printf "\n%b\n" "$HR"
  if [[ -z "$ASSUME_YES" ]]; then
    printf '%b' "  ${CYN}?${R}  Bootstrap GitHub labels? ${D}(requires gh auth + remote repo)${R} [y/N] "
    read -r _ans
    if [[ "$_ans" =~ ^[Yy]$ ]]; then
      cmd_labels
    fi
  fi

  local PROJECT_NAME
  PROJECT_NAME="$(basename "$TARGET_DIR")"

  printf "\n%b\n" "$HR"
  printf "  ${BGRN}✓${R}  ${B}Squad ready${R}  ${D}→${R}  %s\n\n" "$TARGET_DIR"
  printf '%b\n' "  ${D}Next steps:${R}"
  [[ "$TARGET_DIR" != "$(pwd)" ]] && \
    printf "  ${BCYN}›${R}  ${D}cd${R} ${B}%s${R}\n" "$PROJECT_NAME"
  printf "  ${BCYN}›${R}  ${D}gh repo create${R} ${B}%s${R} ${D}--public --push --source=.${R}\n" "$PROJECT_NAME"
  printf '%b\n' "  ${BCYN}›${R}  ${D}claude${R} ${B}/feature${R} ${D}\"your first feature\"${R}"
  printf "\n%b\n\n" "$HR"
}

# ─── labels ───────────────────────────────────────────────────────────────────
cmd_labels() {
  header "Bootstrap GitHub Labels"

  local REPO="${1:-}"
  [[ -z "$REPO" ]] && \
    REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || true)
  [[ -z "$REPO" ]] && \
    fail "Could not detect repository.  Pass owner/repo as argument:\n     ai-squad labels owner/repo"

  info "Repository  " "$REPO"

  local CREATED=0 SKIPPED=0

  label() {
    local name="$1" color="$2" desc="$3"
    if gh label create "$name" --repo "$REPO" --color "$color" \
         --description "$desc" --force &>/dev/null; then
      ok "$name" "$desc"
      CREATED=$((CREATED + 1))
    else
      printf "  ${D}–  %-30s  already exists${R}\n" "$name"
      SKIPPED=$((SKIPPED + 1))
    fi
  }

  printf '%b\n' "  ${B}${BCYN}Story & Type${R}"
  label "story"        "0075ca" "User story"
  label "bug"          "d73a4a" "Bug report"
  label "must-have"    "e11d48" "MoSCoW: Must have"
  label "should-have"  "f97316" "MoSCoW: Should have"
  label "could-have"   "eab308" "MoSCoW: Could have"
  label "wont-have"    "6b7280" "MoSCoW: Won't have"

  printf '\n%b\n' "  ${B}${BCYN}Pipeline Phases${R}"
  label "phase:discover"   "dbeafe" "Phase 1: Discovery"
  label "phase:architect"  "c7d2fe" "Phase 2: Architecture"
  label "phase:plan"       "e9d5ff" "Phase 3: Planning"
  label "phase:infra"      "fce7f3" "Phase 4: Infrastructure"
  label "phase:implement"  "d1fae5" "Phase 5: Implementation"
  label "phase:validate"   "bfdbfe" "Phase 6: Validation"
  label "phase:document"   "fef3c7" "Phase 7: Documentation"
  label "phase:done"       "dcfce7" "Phase 8: Complete"

  printf '\n%b\n' "  ${B}${BCYN}Status${R}"
  label "in-progress"      "fde68a" "Work in progress"
  label "blocked"          "fca5a5" "Blocked — needs human intervention"
  label "validated"        "86efac" "All tests passing"
  label "ready-for-review" "a5f3fc" "PR ready for review"

  printf '\n%b\n' "  ${B}${BCYN}TDD State${R}"
  label "tdd:red"      "fca5a5" "Failing test written"
  label "tdd:green"    "86efac" "Tests passing"
  label "tdd:refactor" "fde68a" "Refactor phase"

  _config_set "labels.last_repo" "$REPO"
  _config_set "labels.last_run"  "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  printf "\n%b\n" "$HR"
  printf '%b' "  ${BGRN}✓${R}  ${B}Done.${R}  "
  printf '%b%d created%b  %b·%b  %b%d skipped%b\n' "${GRN}" "$CREATED" "${R}" "${D}" "${R}" "${D}" "$SKIPPED" "${R}"
  printf '  %b›  https://github.com/%s/labels%b\n\n' "${D}" "$REPO" "${R}"
}

# ─── swarm ────────────────────────────────────────────────────────────────────
_swarm_require_zellij() {
  command -v zellij &>/dev/null || \
    fail "zellij not installed.  Install with: brew install zellij"
  local _ver _major _rest _minor
  _ver=$(zellij --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
  _major="${_ver%%.*}"; _rest="${_ver#*.}"; _minor="${_rest%%.*}"
  if [[ -z "$_ver" ]] || \
     [[ "${_major:-0}" -eq 0 && "${_minor:-0}" -lt 41 ]]; then
    fail "zellij >= 0.41.0 required (found ${_ver:-unknown}).  Upgrade: brew upgrade zellij"
  fi
}

_kdl_escape() {
  # Escape backslashes and double-quotes for KDL string literals
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

_swarm_require_plan() {
  if [[ -f "$PLAN_FILE" ]]; then
    return 0
  fi
  # Auto-detect: scan docs/specs/*/plan.md and use the last one found (glob sort).
  local _p _found=""
  for _p in docs/specs/*/plan.md; do
    [[ -f "$_p" ]] && _found="$_p"
  done
  if [[ -n "$_found" ]]; then
    PLAN_FILE="$_found"
    info "Plan" "auto-detected: $PLAN_FILE"
    return 0
  fi
  fail "Plan file not found: ${PLAN_FILE}\n     Run: ai-squad swarm feature \"<description>\"  to generate one.\n     Or:  PLAN_FILE=docs/specs/<slug>/plan.md ai-squad swarm full"
}

_extract_tasks() {
  grep -E '^\- \[ \] Task [0-9]+:' "$PLAN_FILE" 2>/dev/null || true
}

_parse_agent() { echo "$1" | grep -oE '@[a-zA-Z0-9_-]+' | head -1; }
_parse_desc()  {
  local task="$1" agent="$2"
  echo "$task" | sed "s/.*${agent}//" | sed 's/^[[:space:]]*//'
}

_swarm_init_session() {
  # Create .swarm/{session}/ and return the swarm_dir path via stdout.
  local session="$1" project_dir="$2"
  local swarm_dir="$project_dir/.swarm/$session"
  mkdir -p "$swarm_dir/agents" || { printf 'ERROR: cannot create %s\n' "$swarm_dir" >&2; return 1; }
  local now; now="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  printf '{"session":"%s","project":"%s","started_at":"%s"}\n' \
    "$session" "$project_dir" "$now" > "$swarm_dir/session.json"
  printf '%s' "$swarm_dir"
}

_swarm_session_dir() {
  # Find the most recent .swarm/swarm-* directory in project_dir (or pwd).
  local project_dir="${1:-$(pwd)}"
  local swarm_base="$project_dir/.swarm"
  [[ -d "$swarm_base" ]] || { printf ''; return 0; }
  local d latest=""
  for d in "$swarm_base"/swarm-*/; do
    [[ -d "$d" ]] && latest="${d%/}"
  done
  printf '%s' "$latest"
}


cmd_swarm() {
  local sub="${1:-}"; shift || true
  local _PROJECT_DIR; _PROJECT_DIR="$(pwd)"
  local _WRAPPER; _WRAPPER="$SCRIPTS_DIR/swarm-agent-wrapper.sh"
  local _DASHBOARD; _DASHBOARD="$SCRIPTS_DIR/swarm-dashboard.sh"
  local _MERGE_SCRIPT; _MERGE_SCRIPT="$SCRIPTS_DIR/swarm-merge.sh"

  case "$sub" in
    "")
      # ── Interactive mode: open orchestrator chat, user types the request ──────
      local SESSION; SESSION="swarm-$(date +%s)"
      local SWARM_DIR; SWARM_DIR="$(_swarm_init_session "$SESSION" "$_PROJECT_DIR")"

      header "Swarm"
      _swarm_require_zellij
      [[ -n "${ZELLIJ:-}" ]] && fail "Already inside Zellij.  Detach first (Ctrl-o d)"

      info "Session " "$SESSION"
      info "SwarmDir" "$SWARM_DIR"
      printf "\n%b\n" "$HR"
      printf '%b\n' "  ${D}Type your feature request in the orchestrator chat.${R}"
      printf '%b\n' "  ${D}Phases 1-3 run automatically, then agents launch in new tabs.${R}"
      printf '%b\n' "  ${D}You will be prompted to review plan.md before agents start.${R}"
      printf "%b\n\n" "$HR"

      local _LTMP; _LTMP="$(mktemp -d "${TMPDIR:-/tmp}/ai-squad-XXXXXX")"
      local LAYOUT="${_LTMP}/layout.kdl"
      local _d_esc; _d_esc="$(_kdl_escape "$_PROJECT_DIR")"
      local _dash_esc; _dash_esc="$(_kdl_escape "$_DASHBOARD")"
      local _sw_esc; _sw_esc="$(_kdl_escape "$SWARM_DIR")"
      local _sess_esc; _sess_esc="$(_kdl_escape "$SESSION")"
      local _ctx_esc; _ctx_esc="$(_kdl_escape "AI Squad Swarm Session: ${SESSION}. Swarm dir: ${SWARM_DIR}. Project: ${_PROJECT_DIR}. You are in interactive swarm mode — greet the user and ask what feature they want to build. Once they describe it, run Phases 1-3 (DISCOVER, ARCHITECT, PLAN). Write plan.md to docs/specs/<feature-slug>/plan.md then stop. The swarm dashboard will auto-launch agents when plan.md appears.")"

      cat > "$LAYOUT" <<KDL
layout {
    cwd "${_d_esc}"
    tab name="orchestrator" focus=true {
        pane command="claude" {
            args "--agent" "orchestrator" "${_ctx_esc}"
        }
        pane size=14 command="bash" {
            args "${_dash_esc}" "${_sess_esc}" "${_sw_esc}" "${_d_esc}"
        }
    }
}
KDL

      _config_set "swarm.last_subcommand" "interactive"
      _config_set "swarm.last_session"   "$SESSION"
      _config_set "swarm.last_run"       "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info
      zellij --layout "$LAYOUT"
      rm -rf "$_LTMP"
      ;;
    full)
      local SESSION; SESSION="swarm-$(date +%s)"
      header "Swarm  —  Full Plan"
      _swarm_require_zellij
      _swarm_require_plan
      [[ -n "${ZELLIJ:-}" ]] && fail "Already inside Zellij.  Detach first (Ctrl-o d)"

      TASKS=()
      while IFS= read -r _tline; do TASKS+=("$_tline"); done < <(_extract_tasks)
      [[ ${#TASKS[@]} -eq 0 ]] && \
        fail "No unchecked tasks found in ${PLAN_FILE}\n     All tasks may already be complete."

      local SWARM_DIR; SWARM_DIR="$(_swarm_init_session "$SESSION" "$_PROJECT_DIR")"

      info "Plan   " "$PLAN_FILE"
      info "Session" "$SESSION"
      info "Agents " "${#TASKS[@]}"
      printf "\n%b\n" "$HR"

      local _LTMP; _LTMP="$(mktemp -d "${TMPDIR:-/tmp}/ai-squad-XXXXXX")"
      local LAYOUT="${_LTMP}/layout.kdl"
      local _d_esc; _d_esc="$(_kdl_escape "$_PROJECT_DIR")"
      local _dash_esc; _dash_esc="$(_kdl_escape "$_DASHBOARD")"
      local _sw_esc; _sw_esc="$(_kdl_escape "$SWARM_DIR")"
      local _sess_esc; _sess_esc="$(_kdl_escape "$SESSION")"
      local _wrap_esc; _wrap_esc="$(_kdl_escape "$_WRAPPER")"

      # Pre-create agent dirs so dashboard auto-detects monitor mode
      local i task agent desc agent_name num agent_dir
      for i in "${!TASKS[@]}"; do
        task="${TASKS[$i]}"
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        agent_name="${agent#@}"
        num=$((i + 1))
        agent_dir="$SWARM_DIR/agents/${agent_name}-${num}"
        mkdir -p "$agent_dir"
        printf '%s\n' "$desc"    > "$agent_dir/task.md"
        printf 'pending\n'       > "$agent_dir/status"
        printf 'swarm/%s/%s-%s\n' "$SESSION" "$agent_name" "$num" > "$agent_dir/branch"
        task_row "$num" "$agent" "$desc"
      done
      printf "%b\n\n" "$HR"

      # Tab 1: dashboard (monitor mode — agent dirs already exist)
      {
        printf 'layout {\n'
        printf '    cwd "%s"\n' "$_d_esc"
        printf '    tab name="dashboard" focus=true {\n'
        printf '        pane command="bash" {\n'
        printf '            args "%s" "%s" "%s" "%s"\n' \
          "$_dash_esc" "$_sess_esc" "$_sw_esc" "$_d_esc"
        printf '        }\n'
        printf '    }\n'
      } > "$LAYOUT"

      # Tabs 2+: one wrapper per agent
      for i in "${!TASKS[@]}"; do
        task="${TASKS[$i]}"
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        agent_name="${agent#@}"
        num=$((i + 1))
        local _n_esc; _n_esc="$(_kdl_escape "${agent_name}-${num}")"
        local _a_esc; _a_esc="$(_kdl_escape "$agent_name")"
        local _p_esc; _p_esc="$(_kdl_escape "$desc")"
        local _num_esc; _num_esc="$(_kdl_escape "$num")"
        {
          printf '    tab name="%s" {\n' "$_n_esc"
          printf '        pane command="bash" {\n'
          printf '            args "%s" "--session" "%s" "--agent" "%s"' \
            "$_wrap_esc" "$_sess_esc" "$_a_esc"
          printf ' "--task-num" "%s" "--prompt" "%s"' "$_num_esc" "$_p_esc"
          printf ' "--project-dir" "%s" "--swarm-dir" "%s"\n' "$_d_esc" "$_sw_esc"
          printf '        }\n'
          printf '    }\n'
        } >> "$LAYOUT"
        ok "Queued  ${BCYN}${agent}${R}"
      done
      printf '}\n' >> "$LAYOUT"

      _config_set "swarm.last_subcommand" "full"
      _config_set "swarm.last_args"       "[]"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info
      zellij --layout "$LAYOUT"
      rm -rf "$_LTMP"
      ;;

    tasks)
      [[ $# -eq 0 ]] && fail "Specify task numbers.  Usage: ai-squad swarm tasks 1 3 5"
      local TASK_NUMS=("$@")
      local SESSION; SESSION="swarm-$(date +%s)"

      header "Swarm  —  Selected Tasks"
      _swarm_require_zellij
      _swarm_require_plan
      [[ -n "${ZELLIJ:-}" ]] && fail "Already inside Zellij.  Detach first (Ctrl-o d)"

      ALL_TASKS=()
      while IFS= read -r _tline; do ALL_TASKS+=("$_tline"); done < <(_extract_tasks)
      [[ ${#ALL_TASKS[@]} -eq 0 ]] && fail "No tasks found in ${PLAN_FILE}"

      local SWARM_DIR; SWARM_DIR="$(_swarm_init_session "$SESSION" "$_PROJECT_DIR")"

      info "Session" "$SESSION"
      info "Tasks  " "${TASK_NUMS[*]}"
      printf "\n%b\n" "$HR"

      local _LTMP; _LTMP="$(mktemp -d "${TMPDIR:-/tmp}/ai-squad-XXXXXX")"
      local LAYOUT="${_LTMP}/layout.kdl"
      local _d_esc; _d_esc="$(_kdl_escape "$_PROJECT_DIR")"
      local _dash_esc; _dash_esc="$(_kdl_escape "$_DASHBOARD")"
      local _sw_esc; _sw_esc="$(_kdl_escape "$SWARM_DIR")"
      local _sess_esc; _sess_esc="$(_kdl_escape "$SESSION")"
      local _wrap_esc; _wrap_esc="$(_kdl_escape "$_WRAPPER")"

      # Tab 1: dashboard (monitor mode — agent dirs pre-created below)
      {
        printf 'layout {\n'
        printf '    cwd "%s"\n' "$_d_esc"
        printf '    tab name="dashboard" focus=true {\n'
        printf '        pane command="bash" {\n'
        printf '            args "%s" "%s" "%s" "%s"\n' \
          "$_dash_esc" "$_sess_esc" "$_sw_esc" "$_d_esc"
        printf '        }\n'
        printf '    }\n'
      } > "$LAYOUT"

      local _pane_idx=0 NUM task agent desc agent_name agent_dir
      for NUM in "${TASK_NUMS[@]}"; do
        task=$(printf '%s\n' "${ALL_TASKS[@]}" | grep "Task ${NUM}:" || true)
        if [[ -z "$task" ]]; then
          warn "Task ${NUM} not found in plan — skipping"
          continue
        fi
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        agent_name="${agent#@}"
        task_row "$NUM" "$agent" "$desc"

        # Pre-create agent dir so dashboard sees it immediately
        agent_dir="$SWARM_DIR/agents/${agent_name}-${NUM}"
        mkdir -p "$agent_dir"
        printf '%s\n' "$desc"    > "$agent_dir/task.md"
        printf 'pending\n'       > "$agent_dir/status"
        printf 'swarm/%s/%s-%s\n' "$SESSION" "$agent_name" "$NUM" > "$agent_dir/branch"

        local _n_esc; _n_esc="$(_kdl_escape "${agent_name}-${NUM}")"
        local _a_esc; _a_esc="$(_kdl_escape "$agent_name")"
        local _p_esc; _p_esc="$(_kdl_escape "$desc")"
        local _num_esc; _num_esc="$(_kdl_escape "$NUM")"
        {
          printf '    tab name="%s" {\n' "$_n_esc"
          printf '        pane command="bash" {\n'
          printf '            args "%s" "--session" "%s" "--agent" "%s"' \
            "$_wrap_esc" "$_sess_esc" "$_a_esc"
          printf ' "--task-num" "%s" "--prompt" "%s"' "$_num_esc" "$_p_esc"
          printf ' "--project-dir" "%s" "--swarm-dir" "%s"\n' "$_d_esc" "$_sw_esc"
          printf '        }\n'
          printf '    }\n'
        } >> "$LAYOUT"
        ok "Queued  ${BCYN}${agent}${R}"
        _pane_idx=$((_pane_idx + 1))
      done
      printf '}\n' >> "$LAYOUT"

      if [[ "$_pane_idx" -eq 0 ]]; then
        rm -rf "$_LTMP"
        fail "No valid tasks launched."
      fi

      local _args_json
      _args_json="$(printf '"%s",' "${TASK_NUMS[@]}" | sed 's/,$//')"
      _config_set "swarm.last_subcommand" "tasks"
      _config_set "swarm.last_args"       "[${_args_json}]"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info
      zellij --layout "$LAYOUT"
      rm -rf "$_LTMP"
      ;;

    agent)
      [[ $# -lt 2 ]] && fail "Usage: ai-squad swarm agent @agent-name \"prompt\""
      local AGENT="$1"; shift
      local PROMPT="$*"
      local SESSION; SESSION="swarm-$(date +%s)"

      header "Swarm  —  Single Agent"
      _swarm_require_zellij
      [[ -n "${ZELLIJ:-}" ]] && fail "Already inside Zellij.  Detach first (Ctrl-o d)"

      info "Agent " "$AGENT"
      info "Prompt" "$PROMPT"

      local _LTMP; _LTMP="$(mktemp -d "${TMPDIR:-/tmp}/ai-squad-XXXXXX")"
      local LAYOUT="${_LTMP}/layout.kdl"
      local _name="${AGENT#@}"
      local _n_esc; _n_esc="$(_kdl_escape "$_name")"
      local _p_esc; _p_esc="$(_kdl_escape "$PROMPT")"
      local _d_esc; _d_esc="$(_kdl_escape "$_PROJECT_DIR")"

      cat > "$LAYOUT" <<KDL
layout {
    cwd "${_d_esc}"
    tab name="${_n_esc}" focus=true {
        pane command="claude" {
            args "--agent" "${_n_esc}" "${_p_esc}"
        }
    }
}
KDL

      ok "Launched ${BCYN}${AGENT}${R}"

      local _agent_args
      _agent_args="$(python3 -c "import json,sys; print(json.dumps(sys.argv[1:]))" \
        "$AGENT" "$PROMPT" 2>/dev/null || echo "[]")"
      _config_set "swarm.last_subcommand" "agent"
      _config_set "swarm.last_args"       "$_agent_args"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info
      zellij --layout "$LAYOUT"
      rm -rf "$_LTMP"
      ;;

    feature)
      [[ $# -eq 0 ]] && fail "Usage: ai-squad swarm feature \"<feature description>\""
      local FEATURE_DESC="$*"
      local SESSION; SESSION="swarm-$(date +%s)"
      local SWARM_DIR; SWARM_DIR="$(_swarm_init_session "$SESSION" "$_PROJECT_DIR")"

      header "Swarm  —  Feature Pipeline"
      _swarm_require_zellij
      [[ -n "${ZELLIJ:-}" ]] && fail "Already inside Zellij.  Detach first (Ctrl-o d)"

      info "Feature" "$FEATURE_DESC"
      info "Session" "$SESSION"
      info "SwarmDir" "$SWARM_DIR"
      info "Plan   " "docs/specs/<feature-slug>/plan.md  (auto-detected)"
      printf "\n%b\n" "$HR"
      printf '%b\n' "  ${D}Phase 1-3: orchestrator runs Discover → Architect → Plan.${R}"
      printf '%b\n' "  ${D}Phase 5:   dashboard auto-launches agents once plan.md appears.${R}"
      printf '%b\n' "  ${D}Phase 6+:  orchestrator resumes after all agents complete.${R}"
      printf "%b\n\n" "$HR"

      local _LTMP; _LTMP="$(mktemp -d "${TMPDIR:-/tmp}/ai-squad-XXXXXX")"
      local LAYOUT="${_LTMP}/layout.kdl"
      local _d_esc; _d_esc="$(_kdl_escape "$_PROJECT_DIR")"
      local _f_esc; _f_esc="$(_kdl_escape "Run phases 1-3 only (DISCOVER, ARCHITECT, PLAN). Write plan.md to docs/specs/<feature-slug>/plan.md then stop. Do NOT proceed to Phase 4 or 5. Feature request: ${FEATURE_DESC}")"
      local _dash_esc; _dash_esc="$(_kdl_escape "$_DASHBOARD")"
      local _sw_esc; _sw_esc="$(_kdl_escape "$SWARM_DIR")"
      local _sess_esc; _sess_esc="$(_kdl_escape "$SESSION")"
      local _feat_esc; _feat_esc="$(_kdl_escape "$FEATURE_DESC")"

      cat > "$LAYOUT" <<KDL
layout {
    cwd "${_d_esc}"
    tab name="orchestrator" focus=true {
        pane command="claude" {
            args "--agent" "orchestrator" "${_f_esc}"
        }
        pane size=14 command="bash" {
            args "${_dash_esc}" "${_sess_esc}" "${_sw_esc}" "${_d_esc}" "${_feat_esc}"
        }
    }
}
KDL

      _config_set "swarm.last_subcommand" "feature"
      _config_set "swarm.last_feature"   "$FEATURE_DESC"
      _config_set "swarm.last_session"   "$SESSION"
      _config_set "swarm.last_run"       "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info
      zellij --layout "$LAYOUT"
      rm -rf "$_LTMP"
      ;;

    status)
      local _SID="${1:-}"
      local _swarm_base="$_PROJECT_DIR/.swarm"
      local _STATUS_DIR
      if [[ -n "$_SID" ]]; then
        _STATUS_DIR="$_swarm_base/$_SID"
      else
        _STATUS_DIR="$(_swarm_session_dir "$_PROJECT_DIR")"
      fi
      [[ -z "$_STATUS_DIR" ]] && \
        fail "No swarm session found in ${_swarm_base}\n     Run: ai-squad swarm feature \"<description>\""
      [[ -d "$_STATUS_DIR" ]] || fail "Session dir not found: $_STATUS_DIR"

      local _sname; _sname="$(basename "$_STATUS_DIR")"
      header "Swarm Status  —  $_sname"

      local _adir="$_STATUS_DIR/agents"
      if [[ ! -d "$_adir" ]] || [[ -z "$(ls -A "$_adir" 2>/dev/null)" ]]; then
        info "No agents" "Agents have not been launched yet"
        exit 0
      fi

      printf '\n  %-26s %-10s %-6s %s\n' "AGENT" "STATUS" "EXIT" "BRANCH"
      printf '  ────────────────────────── ────────── ────── ──────\n'

      local _total=0 _done=0 _err=0 _run=0 _pend=0
      local _aname _st _ec _br _ad
      for _ad in "$_adir"/*/; do
        [[ -d "$_ad" ]] || continue
        _aname="$(basename "$_ad")"
        _st="---" _ec="---" _br="---"
        [[ -f "$_ad/status" ]]    && _st="$(cat "$_ad/status")"
        [[ -f "$_ad/exit_code" ]] && _ec="$(cat "$_ad/exit_code")"
        [[ -f "$_ad/branch" ]]    && _br="$(cat "$_ad/branch")"
        printf '  %-26s %-10s %-6s %s\n' "$_aname" "$_st" "$_ec" "$_br"
        _total=$((_total + 1))
        case "$_st" in
          done)    _done=$((_done+1)) ;;
          error)   _err=$((_err+1)) ;;
          running) _run=$((_run+1)) ;;
          *)       _pend=$((_pend+1)) ;;
        esac
      done
      printf '\n  %d total  ·  %d done  ·  %d running  ·  %d error  ·  %d pending\n\n' \
        "$_total" "$_done" "$_run" "$_err" "$_pend"
      ;;

    merge)
      local _SID="${1:-}"
      local _swarm_base="$_PROJECT_DIR/.swarm"
      local _MERGE_DIR
      if [[ -n "$_SID" ]]; then
        _MERGE_DIR="$_swarm_base/$_SID"
      else
        _MERGE_DIR="$(_swarm_session_dir "$_PROJECT_DIR")"
      fi
      [[ -z "$_MERGE_DIR" ]] && \
        fail "No swarm session found in ${_swarm_base}\n     Run: ai-squad swarm feature \"<description>\""
      [[ -d "$_MERGE_DIR" ]] || fail "Session dir not found: $_MERGE_DIR"

      local _sname; _sname="$(basename "$_MERGE_DIR")"
      header "Swarm Merge  —  $_sname"
      bash "$_MERGE_SCRIPT" "$_sname" "$_MERGE_DIR" "$_PROJECT_DIR"
      ;;

    help | --help | -h | *)
      banner
      printf '%b\n\n' "  ${B}USAGE${R}"
      printf '%b\n\n' "    ${D}ai-squad swarm${R}  ${D}[subcommand] [arguments]${R}"
      printf "%b\n" "$HR"
      printf '%b\n' "  ${BCYN}(no args)${R}"
      printf '%b\n\n' "  ${D}    Open interactive orchestrator chat — type your feature request inside${R}"
      printf '%b\n' "  ${BCYN}feature${R}  ${D}\"<description>\"${R}"
      printf '%b\n\n' "  ${D}    Non-interactive shortcut: pre-loads the feature description${R}"
      printf '%b\n' "  ${BCYN}full${R}"
      printf '%b\n' "  ${D}    Launch all unchecked tasks from:${R}"
      printf '  %b    %s%b\n\n' "${D}" "$PLAN_FILE" "${R}"
      printf '%b\n' "  ${BCYN}tasks${R}  ${D}<n> [n...]${R}"
      printf '%b\n\n' "  ${D}    Launch specific task numbers from the plan${R}"
      printf '%b\n' "  ${BCYN}agent${R}  ${D}<@name> <prompt>${R}"
      printf '%b\n\n' "  ${D}    Run a single named agent with a custom prompt${R}"
      printf '%b\n' "  ${BCYN}status${R}  ${D}[session-id]${R}"
      printf '%b\n\n' "  ${D}    Show agent status for the latest (or named) swarm session${R}"
      printf '%b\n' "  ${BCYN}merge${R}   ${D}[session-id]${R}"
      printf '%b\n\n' "  ${D}    Merge completed agent branches into the current branch${R}"
      printf "%b\n" "$HR"
      printf '%b\n\n' "  ${D}PLAN_FILE env var overrides the default plan path${R}"
      ;;
  esac
}

# ─── help ─────────────────────────────────────────────────────────────────────
cmd_help() {
  header "Help"

  printf '%b\n\n' "  ${B}USAGE${R}"
  printf '%b\n' "    ${D}ai-squad${R} ${B}<command>${R} ${D}[arguments]${R}"

  printf "\n%b\n" "$HR"
  printf '%b\n\n' "  ${B}COMMANDS${R}"

  printf '%b\n' "  ${BCYN}init${R}    ${D}[-y|--yes] [project-name]${R}"
  printf '%b\n' "  ${D}    Scaffold the template into a new or existing directory${R}"
  printf '%b\n\n' "  ${D}    --yes / -y  skip all interactive prompts (for CI)${R}"

  printf '%b\n' "  ${BCYN}labels${R}  ${D}[owner/repo]${R}"
  printf '%b\n\n' "  ${D}    Create GitHub issue labels for the squad pipeline${R}"

  printf '%b\n' "  ${BCYN}swarm${R}   ${D}[feature \"...\" | full | tasks <n...> | agent | status | merge]${R}"
  printf '%b\n' "  ${D}    Multi-agent pipeline in Zellij (Claude Code only)${R}"
  printf '%b\n\n' "  ${D}    No args = interactive chat  ·  ai-squad swarm help for all subcommands${R}"

  printf "%b\n" "$HR"
  printf '%b\n\n' "  ${B}EXAMPLES${R}"

  printf '%b\n' "  ${D}# New project${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}init${R} my-project"

  printf '%b\n' "  ${D}# Create labels after connecting a remote repo${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}labels${R}"

  printf '%b\n' "  ${D}# Full pipeline: plan + swarm in one command${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}swarm feature${R} ${D}\"add user authentication with JWT\"${R}"

  printf '%b\n' "  ${D}# Run all plan tasks in parallel (plan already exists)${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}swarm full${R}"

  printf '%b\n' "  ${D}# Run specific tasks${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}swarm tasks${R} 1 3 5"

  printf '%b\n' "  ${D}# Single agent${R}"
  printf '%b\n' "  ${BCYN}ai-squad${R} ${B}swarm agent${R} @dotnet ${D}\"make OrderTests.cs pass\"${R}"

  printf "\n%b\n" "$HR"
  printf '  %bTemplate:  %s%b\n\n' "${D}" "$TEMPLATE_DIR" "${R}"
}

# ─── Dispatch ─────────────────────────────────────────────────────────────────
_config_init
_play_jingle

case "${1:-help}" in
  init)               shift; cmd_init   "$@" ;;
  labels)             shift; cmd_labels "$@" ;;
  swarm)              shift; cmd_swarm  "$@" ;;
  help | -h | --help) cmd_help ;;
  *)
    printf "\n  %b✗%b  Unknown command: %b%s%b\n" "${BRED}" "${R}" "${B}" "$1" "${R}" >&2
    printf '%b\n\n' "  ${D}Run${R} ${B}ai-squad help${R} ${D}for available commands.${R}" >&2
    exit 1
    ;;
esac
