#!/usr/bin/env bash
# ai-squad — AI Development Squad CLI
#
# Install globally:
#   git clone https://github.com/kinncj/AI-Development-Squad-Template.git ~/.ai-squad
#   echo 'export PATH="$HOME/.ai-squad/scripts:$PATH"' >> ~/.zshrc
#   source ~/.zshrc
#
# Usage:
#   ai-squad init   [project-name]          Scaffold template into new or current directory
#   ai-squad labels [owner/repo]            Create GitHub labels in current repo
#   ai-squad swarm  full                    Launch all plan tasks in parallel tmux panes
#   ai-squad swarm  tasks <n> [n...]        Launch specific task numbers
#   ai-squad swarm  agent <@name> <prompt>  Run a single named agent
#   ai-squad help                           Show this help
#
# Copyright (C) 2025 Kinn Coelho Juliao <kinncj@protonmail.com>
# SPDX-License-Identifier: AGPL-3.0-or-later
set -euo pipefail

TOOL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
TEMPLATE_DIR="$TOOL_DIR/template"
PLAN_FILE="${PLAN_FILE:-docs/specs/current/plan.md}"
GLOBAL_CONFIG="$HOME/.ai-squad.json"   # jingle state — once ever, across all projects
CONFIG_FILE="$(pwd)/.ai-squad.json"    # project options — per working directory

# ─── Colour palette ───────────────────────────────────────────────────────────
if [[ -n "${NO_COLOR:-}" || "${TERM:-}" == "dumb" || ! -t 1 ]]; then
  R=''; B=''; D=''; GRN=''; YLW=''; CYN=''
  BGRN=''; BRED=''; BYEL=''; BCYN=''; BMGT=''
  HGRN=''  # hacker green (for banner)
else
  R='\033[0m';    B='\033[1m';    D='\033[2m'
  GRN='\033[0;32m';  YLW='\033[0;33m';  CYN='\033[0;36m'
  BGRN='\033[1;32m'; BRED='\033[1;31m'; BYEL='\033[1;33m'
  BCYN='\033[1;36m'; BMGT='\033[1;35m'
  HGRN='\033[0;32m'  # hacker green
fi

HR="  ${D}$(printf '─%.0s' {1..60})${R}"

# ─── ASCII banner ─────────────────────────────────────────────────────────────
_BANNER_ROWS=(
  "                                                                    "
  "   ▄▄▄▄   ▄▄▄▄▄    ▄▄▄▄▄▄▄   ▄▄▄▄▄   ▄▄▄  ▄▄▄   ▄▄▄▄   ▄▄▄▄▄▄   "
  "  ▄██▀▀██▄  ███    █████▀▀▀ ▄███████▄ ███  ███ ▄██▀▀██▄ ███▀▀██▄  "
  "  ███  ███  ███     ▀████▄  ███   ███ ███  ███ ███  ███ ███  ███   "
  "  ███▀▀███  ███       ▀████ ███▄█▄███ ███▄▄███ ███▀▀███ ███  ███   "
  "  ███  ███ ▄███▄   ███████▀  ▀█████▀  ▀██████▀ ███  ███ ██████▀   "
  "                          ▀▀                                        "
  "                                                                    "
)
_BANNER_DONE=''

banner() {
  [[ -z "$HGRN" ]] && return

  local N=${#_BANNER_ROWS[@]}  # 8 rows total

  # Subsequent calls (e.g. swarm help after init): print statically, no re-animation
  if [[ -n "$_BANNER_DONE" ]]; then
    printf '%b' "${HGRN}"
    local _r; for _r in "${_BANNER_ROWS[@]}"; do printf '%s\n' "$_r"; done
    printf '%b' "${R}"
    return
  fi
  _BANNER_DONE=1

  # Reserve vertical space for the animation area
  local _i; for ((_i=0; _i<N; _i++)); do printf '\n'; done

  # ── Frame 0: edge-on ─────────────────────────────────────────────────────
  # Single dim line at mid-height simulates the card seen edge-on.
  printf '\033[%dA' "${N}"
  for ((_i=0; _i<N; _i++)); do
    if ((_i == 3)); then
      printf '\033[2K%b\n' \
        "${D}  ──────────────────────────────────────────────────────────────────${R}"
    else
      printf '\033[2K\n'
    fi
  done
  sleep 0.06

  # ── Frames 1-3: expand from center outward ────────────────────────────────
  # Content rows live at indices 1-6.  Center pair: rows 3-4.
  # f=2 → show 2 rows (3-4); f=1 → show 4 rows (2-5); f=0 → show 6 rows (1-6).
  local _f _top _rows
  for _f in 2 1 0; do
    _top=$((_f + 1))        # first visible content index
    _rows=$((6 - 2 * _f))  # rows to reveal: 2, 4, 6
    printf '\033[%dA' "${N}"
    printf '%b' "${HGRN}"
    for ((_i=0; _i<N; _i++)); do
      if ((_i >= _top && _i < _top + _rows)); then
        printf '\033[2K%s\n' "${_BANNER_ROWS[$_i]}"
      else
        printf '\033[2K\n'
      fi
    done
    sleep 0.07
  done

  printf '%b' "${R}"
}

# ─── UI primitives ────────────────────────────────────────────────────────────
header() {
  banner
  printf "  ${B}${BMGT}AI Development Squad${R}  ${D}·${R}  ${B}%s${R}\n" "$1"
  printf "%b\n\n" "$HR"
}

step()    { printf "\n  ${BCYN}›${R}  ${B}%s${R}\n" "$1"; }
ok()      { printf "  ${BGRN}✓${R}  %-32s  ${D}%s${R}\n" "$1" "${2:-}"; }
info()    { printf "  ${CYN}›${R}  %-16s${B}%s${R}\n" "$1" "${2:-}"; }
warn()    { printf "  ${BYEL}!${R}  ${YLW}%s${R}\n" "$1"; }
missing() { printf "  ${BYEL}?${R}  %-32s  ${YLW}not found — %s${R}\n" "$1" "$2"; }
fail()    { printf "\n  ${BRED}✗${R}  ${B}%s${R}\n\n" "$*" >&2; exit 1; }

task_row() {
  local n="$1" agent="$2" desc="$3"
  printf "  ${D}[%2d]${R}  ${BCYN}%-22s${R}  %s\n" "$n" "$agent" "$desc"
}

session_info() {
  local session="$1"
  printf "\n%b\n" "$HR"
  printf "  ${CYN}›${R}  Session   ${B}%s${R}\n" "$session"
  printf '%b\n' "  ${D}›  Detach   Ctrl-b d${R}"
  printf "  ${D}›  Kill     tmux kill-session -t %s${R}\n" "$session"
  printf "%b\n\n" "$HR"
}

# ─── Config & jingle ──────────────────────────────────────────────────────────
_config_init() {
  command -v python3 &>/dev/null || return 0
  # Global config — tracks jingle state
  if [[ ! -f "$GLOBAL_CONFIG" ]]; then
    python3 - "$GLOBAL_CONFIG" <<'PYEOF'
import json, sys
with open(sys.argv[1], "w") as f:
    json.dump({"jingle_played": False}, f, indent=2)
    f.write("\n")
PYEOF
  fi
  # Project config — tracks last-used options for this working directory
  if [[ ! -f "$CONFIG_FILE" ]]; then
    python3 - "$CONFIG_FILE" <<'PYEOF'
import json, sys
with open(sys.argv[1], "w") as f:
    json.dump({"init": {}, "labels": {}, "swarm": {}}, f, indent=2)
    f.write("\n")
PYEOF
  fi
}

_config_set() {
  # _config_set <dot.key> <value>
  # JSON literals (true/false/arrays/numbers) are preserved; bare strings stored as-is.
  command -v python3 &>/dev/null || return 0
  [[ -f "$CONFIG_FILE" ]] || return 0
  python3 - "$CONFIG_FILE" "$1" "$2" <<'PYEOF'
import json, sys
path, dotkey, raw = sys.argv[1], sys.argv[2], sys.argv[3]
try:
    with open(path) as f:
        cfg = json.load(f)
except Exception:
    cfg = {}
keys = dotkey.split(".")
d = cfg
for k in keys[:-1]:
    d = d.setdefault(k, {})
try:
    d[keys[-1]] = json.loads(raw)
except Exception:
    d[keys[-1]] = raw
with open(path, "w") as f:
    json.dump(cfg, f, indent=2)
    f.write("\n")
PYEOF
}

_config_get() {
  command -v python3 &>/dev/null || { echo ""; return 0; }
  [[ -f "$CONFIG_FILE" ]] || { echo ""; return 0; }
  python3 - "$CONFIG_FILE" "$1" <<'PYEOF'
import json, sys
try:
    with open(sys.argv[1]) as f:
        v = json.load(f)
    for k in sys.argv[2].split("."):
        v = v[k]
    print(json.dumps(v) if not isinstance(v, str) else v)
except Exception:
    print("")
PYEOF
}

# Read one key from the global config (jingle state lives here).
# Called via $() so heredoc must NOT be used inline — logic lives in the function body.
_global_config_get() {
  command -v python3 &>/dev/null || { echo ""; return 0; }
  [[ -f "$GLOBAL_CONFIG" ]] || { echo ""; return 0; }
  python3 - "$GLOBAL_CONFIG" "$1" <<'PYEOF'
import json, sys
try:
    with open(sys.argv[1]) as f:
        v = json.load(f)
    for k in sys.argv[2].split("."):
        v = v[k]
    print(json.dumps(v) if not isinstance(v, str) else v)
except Exception:
    print("")
PYEOF
}

_global_config_set() {
  command -v python3 &>/dev/null || return 0
  [[ -f "$GLOBAL_CONFIG" ]] || return 0
  python3 - "$GLOBAL_CONFIG" "$1" "$2" <<'PYEOF'
import json, sys
path, dotkey, raw = sys.argv[1], sys.argv[2], sys.argv[3]
try:
    with open(path) as f:
        cfg = json.load(f)
except Exception:
    cfg = {}
keys = dotkey.split(".")
d = cfg
for k in keys[:-1]:
    d = d.setdefault(k, {})
try:
    d[keys[-1]] = json.loads(raw)
except Exception:
    d[keys[-1]] = raw
with open(path, "w") as f:
    json.dump(cfg, f, indent=2)
    f.write("\n")
PYEOF
}

_play_jingle() {
  local jingle="$TOOL_DIR/AI_SQUAD_JINGLE.wav"
  [[ -f "$jingle" ]] || return 0
  [[ "$(_global_config_get jingle_played)" == "true" ]] && return 0
  _global_config_set "jingle_played" "true"   # mark before playing (fire-and-forget)
  # Launch audio in background. Never crash — all errors are silently swallowed.
  {
    if command -v afplay &>/dev/null; then
      # macOS — afplay only handles PCM WAV; use Python3 to unwrap MP3-in-RIFF if needed
      python3 - "$jingle" <<'PYEOF'
import sys, struct, tempfile, os, subprocess

path = sys.argv[1]
with open(path, 'rb') as f:
    data = f.read()

play_path = path
tmp = None

if data[:4] == b'RIFF' and data[8:12] == b'WAVE':
    i = 12
    while i < len(data) - 8:
        cid = data[i:i+4]
        csz = struct.unpack_from('<I', data, i+4)[0]
        if cid == b'data':
            raw = data[i+8:i+8+csz]
            # MP3 sync: ID3 tag or 0xFF 0xEx/0xFF 0xFx frame header
            if raw[:3] == b'ID3' or (len(raw) > 1 and raw[0] == 0xFF and raw[1] & 0xE0 == 0xE0):
                tmp = tempfile.NamedTemporaryFile(suffix='.mp3', delete=False)
                tmp.write(raw)
                tmp.close()
                play_path = tmp.name
            break
        i += 8 + max(csz, 1)

try:
    subprocess.run(['afplay', play_path],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
finally:
    if tmp:
        os.unlink(tmp.name)
PYEOF
    elif command -v paplay         &>/dev/null; then
      # Linux — PulseAudio / PipeWire
      paplay "$jingle"
    elif command -v aplay          &>/dev/null; then
      # Linux — ALSA
      aplay -q "$jingle"
    elif command -v powershell.exe &>/dev/null; then
      # Windows — Git Bash / WSL boundary
      local _win_path
      _win_path="$(command -v cygpath &>/dev/null && cygpath -w "$jingle" 2>/dev/null || echo "$jingle")"
      powershell.exe -NoProfile -Command \
        "(New-Object Media.SoundPlayer '$_win_path').PlaySync()"
    fi
  } >/dev/null 2>&1 &
}

# ─── OpenCode model configuration ─────────────────────────────────────────────
_oc_replace_in_file() {
  # _oc_replace_in_file <file> <from> <to>
  command -v python3 &>/dev/null || return 0
  [[ -f "$1" ]] || return 0
  python3 - "$1" "$2" "$3" <<'PYEOF'
import sys
path, old, new = sys.argv[1], sys.argv[2], sys.argv[3]
with open(path) as f:
    content = f.read()
if old in content:
    with open(path, 'w') as f:
        f.write(content.replace(old, new))
PYEOF
}

_oc_replace_all() {
  # _oc_replace_all <agents-dir> <opencode-json> <from> <to>
  local dir="$1" json="$2" from="$3" to="$4"
  for f in "$dir"/*.md; do
    [[ -f "$f" ]] && _oc_replace_in_file "$f" "$from" "$to"
  done
  [[ -f "$json" ]] && _oc_replace_in_file "$json" "$from" "$to"
}

_configure_opencode_models() {
  local TARGET="$1"
  local AGENTS_DIR="$TARGET/.opencode/agent"
  local OC_JSON="$TARGET/opencode.json"

  [[ -d "$AGENTS_DIR" ]] || return 0

  step "Configuring OpenCode model providers"

  local HAS_ANTHROPIC='' HAS_COPILOT=''

  printf '%b' "  ${CYN}?${R}  Do you have a ${B}Claude Code${R} (Anthropic API) account? [y/N] "
  read -r _ans
  [[ "$_ans" =~ ^[Yy]$ ]] && HAS_ANTHROPIC=1

  printf '%b' "  ${CYN}?${R}  Do you have a ${B}GitHub Copilot${R} account? [y/N] "
  read -r _ans
  [[ "$_ans" =~ ^[Yy]$ ]] && HAS_COPILOT=1

  local COPILOT_SONNET="claude-sonnet-4.5"
  local COPILOT_OPUS="claude-opus-4.5"

  if [[ -n "$HAS_COPILOT" ]]; then
    printf '%b' "  ${CYN}?${R}  Do you have access to ${B}Claude Sonnet 4.6${R} in GitHub Copilot? [y/N] "
    read -r _ans
    [[ "$_ans" =~ ^[Yy]$ ]] && COPILOT_SONNET="claude-sonnet-4.6"

    printf '%b' "  ${CYN}?${R}  Do you have access to ${B}Claude Opus 4.6${R} in GitHub Copilot? [y/N] "
    read -r _ans
    [[ "$_ans" =~ ^[Yy]$ ]] && COPILOT_OPUS="claude-opus-4.6"
  fi

  local _provider

  if [[ -n "$HAS_ANTHROPIC" && -n "$HAS_COPILOT" ]]; then
    # Both: keep anthropic defaults for orchestration; upgrade copilot impl models if available
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-sonnet-4.5" "github-copilot/${COPILOT_SONNET}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-opus-4.5"   "github-copilot/${COPILOT_OPUS}"
    ok "Both providers" "anthropic/* orchestration · github-copilot/${COPILOT_SONNET} implementation"
    _provider="both"

  elif [[ -n "$HAS_ANTHROPIC" ]]; then
    # Anthropic API only — route everything through anthropic/
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-sonnet-4.5" "anthropic/claude-sonnet-4-6"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-opus-4.5"   "anthropic/claude-opus-4-6"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "copilot/gpt-4.1"                  "anthropic/claude-sonnet-4-6"
    ok "Anthropic only" "anthropic/claude-opus-4-6 · anthropic/claude-sonnet-4-6"
    _provider="anthropic"

  elif [[ -n "$HAS_COPILOT" ]]; then
    # GitHub Copilot only — route everything through github-copilot/
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "anthropic/claude-opus-4-6"        "github-copilot/${COPILOT_OPUS}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "anthropic/claude-sonnet-4-6"      "github-copilot/${COPILOT_SONNET}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-sonnet-4.5" "github-copilot/${COPILOT_SONNET}"
    _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
      "github-copilot/claude-opus-4.5"   "github-copilot/${COPILOT_OPUS}"
    ok "GitHub Copilot only" "github-copilot/${COPILOT_OPUS} · github-copilot/${COPILOT_SONNET}"
    _provider="copilot"

  else
    # No commercial subscription — offer free/local alternatives
    printf '\n'
    warn "No provider selected. The squad needs at least one model provider."
    printf '\n'
    printf '%b\n' "  ${BCYN}Free cloud models${R}  ${D}(require an opencode provider connection)${R}"
    printf '%b\n' "  ${D}[1]${R}  opencode/big-pickle"
    printf '%b\n' "  ${D}[2]${R}  opencode/glm-5-free"
    printf '%b\n' "  ${D}[3]${R}  opencode/gpt-5-nano"
    printf '%b\n' "  ${D}[4]${R}  opencode/kimi-k2.5-free"
    printf '%b\n' "  ${D}[5]${R}  opencode/minimax-m2.5-free"
    printf '%b\n' "  ${BCYN}Local models${R}  ${D}(require Ollama running locally)${R}"
    printf '%b\n' "  ${D}[6]${R}  ollama/llama3.2:latest"
    printf '%b\n' "  ${D}[7]${R}  Custom Ollama model ID"
    printf '%b\n' "  ${D}[8]${R}  Skip — configure manually later"
    printf '\n'

    local BIG_MODEL FAST_MODEL _pick

    printf '%b' "  ${CYN}?${R}  ${B}Big model${R}  ${D}(orchestrator, architect — heavy reasoning)${R} [1-8]: "
    read -r _pick
    case "$_pick" in
      1) BIG_MODEL="opencode/big-pickle" ;;
      2) BIG_MODEL="opencode/glm-5-free" ;;
      3) BIG_MODEL="opencode/gpt-5-nano" ;;
      4) BIG_MODEL="opencode/kimi-k2.5-free" ;;
      5) BIG_MODEL="opencode/minimax-m2.5-free" ;;
      6) BIG_MODEL="ollama/llama3.2:latest" ;;
      7)
        printf '%b' "  ${CYN}?${R}  Custom Ollama model (e.g. ollama/mistral:latest): "
        read -r BIG_MODEL
        ;;
      *) BIG_MODEL="" ;;
    esac

    printf '%b' "  ${CYN}?${R}  ${B}Fast model${R}  ${D}(all implementation agents)${R} [1-8]: "
    read -r _pick
    case "$_pick" in
      1) FAST_MODEL="opencode/big-pickle" ;;
      2) FAST_MODEL="opencode/glm-5-free" ;;
      3) FAST_MODEL="opencode/gpt-5-nano" ;;
      4) FAST_MODEL="opencode/kimi-k2.5-free" ;;
      5) FAST_MODEL="opencode/minimax-m2.5-free" ;;
      6) FAST_MODEL="ollama/llama3.2:latest" ;;
      7)
        printf '%b' "  ${CYN}?${R}  Custom Ollama model (e.g. ollama/mistral:latest): "
        read -r FAST_MODEL
        ;;
      *) FAST_MODEL="" ;;
    esac

    if [[ -z "$BIG_MODEL" || -z "$FAST_MODEL" ]]; then
      warn "Skipping model configuration — edit .opencode/agents/*.md manually."
      _provider="manual"
    else
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "anthropic/claude-opus-4-6"        "$BIG_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "github-copilot/claude-opus-4.5"   "$BIG_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "anthropic/claude-sonnet-4-6"      "$FAST_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "github-copilot/claude-sonnet-4.5" "$FAST_MODEL"
      _oc_replace_all "$AGENTS_DIR" "$OC_JSON" \
        "copilot/gpt-4.1"                  "$FAST_MODEL"
      ok "Models configured" "${BIG_MODEL} · ${FAST_MODEL}"
      _provider="free"

      # Provider connection instructions
      printf '\n%b\n' "$HR"
      printf '%b\n' "  ${BYEL}!${R}  ${B}Action required: connect providers in OpenCode${R}"
      printf '\n'
      if [[ "$BIG_MODEL" == opencode/* || "$FAST_MODEL" == opencode/* ]]; then
        printf '%b\n' "  ${BCYN}opencode/* models${R} — add the opencode provider:"
        printf '%b\n' "  ${D}  opencode → Settings → Providers → opencode${R}"
        printf '%b\n' "  ${D}  Get your API key at https://opencode.ai${R}"
        printf '\n'
      fi
      if [[ "$BIG_MODEL" == ollama/* || "$FAST_MODEL" == ollama/* ]]; then
        local _ollama_model
        _ollama_model=$(printf '%s\n%s\n' "$BIG_MODEL" "$FAST_MODEL" \
          | grep '^ollama/' | sed 's|ollama/||' | head -1)
        printf '%b\n' "  ${BCYN}ollama/* models${R} — start Ollama and pull the model:"
        printf '%b\n' "  ${D}  brew install ollama && ollama serve${R}"
        printf '%b  ollama pull %s%b\n' "$D" "$_ollama_model" "$R"
        printf '%b\n' "  ${D}  opencode → Settings → Providers → Ollama (http://localhost:11434)${R}"
        printf '\n'
      fi
      printf '%b\n' "$HR"
    fi
  fi

  _config_set "init.opencode_provider" "${_provider:-unknown}"
}

# ─── init ─────────────────────────────────────────────────────────────────────
cmd_init() {
  local TARGET_DIR ASSUME_YES=''

  # Parse flags before positional argument
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --yes|-y) ASSUME_YES=1; shift ;;
      --) shift; break ;;
      -*) fail "Unknown flag: $1" ;;
      *) break ;;
    esac
  done

  if [[ $# -gt 0 ]]; then
    if [[ "$1" = /* ]]; then
      TARGET_DIR="$1"
    else
      TARGET_DIR="$(pwd)/$1"
    fi
  else
    TARGET_DIR="$(pwd)"
  fi

  header "Initialize Project"
  info "Template" "$TEMPLATE_DIR"
  info "Target  " "$TARGET_DIR"

  if [[ -d "$TARGET_DIR" ]] && [[ -n "$(ls -A "$TARGET_DIR" 2>/dev/null)" ]]; then
    warn "Directory is not empty: $TARGET_DIR"
    if [[ -n "$ASSUME_YES" ]]; then
      warn "Proceeding (--yes)"
    else
      printf '%b' "  ${BYEL}?${R}  Existing files may be overwritten. Continue? [y/N] "
      read -r _ans
      [[ "$_ans" =~ ^[Yy]$ ]] || fail "Aborted."
    fi
  fi

  mkdir -p "$TARGET_DIR"

  step "Checking dependencies"
  local cmd install
  while IFS=: read -r cmd install; do
    if command -v "$cmd" &>/dev/null; then
      ok "$cmd" "$(command -v "$cmd")"
    else
      missing "$cmd" "$install"
    fi
  done <<'DEPS'
git:https://git-scm.com
gh:brew install gh
docker:https://docker.com
node:https://nodejs.org
claude:npm install -g @anthropic-ai/claude-code
DEPS

  step "Copying template"
  rsync -a \
    --exclude='.git' \
    --exclude='node_modules' \
    --exclude='*.log' \
    "$TEMPLATE_DIR/" "$TARGET_DIR/"
  local FILE_COUNT
  FILE_COUNT=$(find "$TARGET_DIR" -type f | wc -l | tr -d ' ')
  ok "Files copied" "$FILE_COUNT files"

  printf "\n%b\n" "$HR"
  if [[ -z "$ASSUME_YES" ]]; then
    _configure_opencode_models "$TARGET_DIR"
  fi

  step "Initializing git repository"
  cd "$TARGET_DIR"
  git init -q
  git add -A
  git commit -q -m "chore: initialize from AI Development Squad Template

Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
Source:    $(basename "$TOOL_DIR")"
  ok "Repository initialized" "commit $(git rev-parse --short HEAD)"
  _config_set "init.last_project" "$(basename "$TARGET_DIR")"
  _config_set "init.last_target"  "$TARGET_DIR"
  _config_set "init.last_run"     "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  if [[ -f "package.json" ]]; then
    step "Installing dependencies"
    npm install --silent
    ok "npm dependencies installed"
    if npx playwright install chromium --quiet 2>/dev/null; then
      ok "Playwright browsers installed"
    else
      warn "Playwright install failed — run: npx playwright install"
    fi
  fi

  printf "\n%b\n" "$HR"
  if [[ -z "$ASSUME_YES" ]]; then
    printf '%b' "  ${CYN}?${R}  Bootstrap GitHub labels? ${D}(requires gh auth + remote repo)${R} [y/N] "
    read -r _ans
    if [[ "$_ans" =~ ^[Yy]$ ]]; then
      cmd_labels
    fi
  fi

  local PROJECT_NAME
  PROJECT_NAME="$(basename "$TARGET_DIR")"

  printf "\n%b\n" "$HR"
  printf "  ${BGRN}✓${R}  ${B}Squad ready${R}  ${D}→${R}  %s\n\n" "$TARGET_DIR"
  printf '%b\n' "  ${D}Next steps:${R}"
  [[ "$TARGET_DIR" != "$(pwd)" ]] && \
    printf "  ${BCYN}›${R}  ${D}cd${R} ${B}%s${R}\n" "$PROJECT_NAME"
  printf "  ${BCYN}›${R}  ${D}gh repo create${R} ${B}%s${R} ${D}--public --push --source=.${R}\n" "$PROJECT_NAME"
  printf '%b\n' "  ${BCYN}›${R}  ${D}claude${R} ${B}/feature${R} ${D}\"your first feature\"${R}"
  printf "\n%b\n\n" "$HR"
}

# ─── labels ───────────────────────────────────────────────────────────────────
cmd_labels() {
  header "Bootstrap GitHub Labels"

  local REPO="${1:-}"
  [[ -z "$REPO" ]] && \
    REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || true)
  [[ -z "$REPO" ]] && \
    fail "Could not detect repository.  Pass owner/repo as argument:\n     ai-squad labels owner/repo"

  info "Repository  " "$REPO"

  local CREATED=0 SKIPPED=0

  label() {
    local name="$1" color="$2" desc="$3"
    if gh label create "$name" --repo "$REPO" --color "$color" \
         --description "$desc" --force &>/dev/null; then
      ok "$name" "$desc"
      CREATED=$((CREATED + 1))
    else
      printf "  ${D}–  %-30s  already exists${R}\n" "$name"
      SKIPPED=$((SKIPPED + 1))
    fi
  }

  printf '%b\n' "  ${B}${BCYN}Story & Type${R}"
  label "story"        "0075ca" "User story"
  label "bug"          "d73a4a" "Bug report"
  label "must-have"    "e11d48" "MoSCoW: Must have"
  label "should-have"  "f97316" "MoSCoW: Should have"
  label "could-have"   "eab308" "MoSCoW: Could have"
  label "wont-have"    "6b7280" "MoSCoW: Won't have"

  printf '\n%b\n' "  ${B}${BCYN}Pipeline Phases${R}"
  label "phase:discover"   "dbeafe" "Phase 1: Discovery"
  label "phase:architect"  "c7d2fe" "Phase 2: Architecture"
  label "phase:plan"       "e9d5ff" "Phase 3: Planning"
  label "phase:infra"      "fce7f3" "Phase 4: Infrastructure"
  label "phase:implement"  "d1fae5" "Phase 5: Implementation"
  label "phase:validate"   "bfdbfe" "Phase 6: Validation"
  label "phase:document"   "fef3c7" "Phase 7: Documentation"
  label "phase:done"       "dcfce7" "Phase 8: Complete"

  printf '\n%b\n' "  ${B}${BCYN}Status${R}"
  label "in-progress"      "fde68a" "Work in progress"
  label "blocked"          "fca5a5" "Blocked — needs human intervention"
  label "validated"        "86efac" "All tests passing"
  label "ready-for-review" "a5f3fc" "PR ready for review"

  printf '\n%b\n' "  ${B}${BCYN}TDD State${R}"
  label "tdd:red"      "fca5a5" "Failing test written"
  label "tdd:green"    "86efac" "Tests passing"
  label "tdd:refactor" "fde68a" "Refactor phase"

  _config_set "labels.last_repo" "$REPO"
  _config_set "labels.last_run"  "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  printf "\n%b\n" "$HR"
  printf '%b' "  ${BGRN}✓${R}  ${B}Done.${R}  "
  printf '%b%d created%b  %b·%b  %b%d skipped%b\n' "${GRN}" "$CREATED" "${R}" "${D}" "${R}" "${D}" "$SKIPPED" "${R}"
  printf '  %b›  https://github.com/%s/labels%b\n\n' "${D}" "$REPO" "${R}"
}

# ─── swarm ────────────────────────────────────────────────────────────────────
_swarm_require_tmux() {
  command -v tmux &>/dev/null || \
    fail "tmux not installed.  Install with: brew install tmux"
}

_swarm_require_plan() {
  [[ -f "$PLAN_FILE" ]] || \
    fail "Plan file not found: ${PLAN_FILE}\n     Run /feature first to generate a plan."
}

_extract_tasks() {
  grep -E '^\- \[ \] Task [0-9]+:' "$PLAN_FILE" 2>/dev/null || true
}

_parse_agent() { echo "$1" | grep -oE '@[a-zA-Z0-9_-]+' | head -1; }
_parse_desc()  {
  local task="$1" agent="$2"
  echo "$task" | sed "s/.*${agent}//" | sed 's/^[[:space:]]*//'
}

_open_pane() {
  local idx="$1" session="$2" agent="$3" desc="$4"
  if [[ "$idx" -gt 0 ]]; then
    tmux split-window -t "$session" -h
    tmux select-layout -t "$session" tiled
  fi
  tmux send-keys -t "$session.$idx" \
    "claude --agent ${agent#@} \"${desc}\"" Enter
}

cmd_swarm() {
  local sub="${1:-help}"; shift || true

  case "$sub" in
    full)
      local SESSION; SESSION="swarm-$(date +%s)"
      header "Swarm  —  Full Plan"
      _swarm_require_tmux
      _swarm_require_plan

      mapfile -t TASKS < <(_extract_tasks)
      [[ ${#TASKS[@]} -eq 0 ]] && \
        fail "No unchecked tasks found in ${PLAN_FILE}\n     All tasks may already be complete."

      info "Plan   " "$PLAN_FILE"
      info "Session" "$SESSION"
      info "Agents " "${#TASKS[@]}"
      printf "\n%b\n" "$HR"

      local i task agent desc
      for i in "${!TASKS[@]}"; do
        task="${TASKS[$i]}"
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        task_row "$((i + 1))" "$agent" "$desc"
      done
      printf "%b\n\n" "$HR"

      tmux new-session -d -s "$SESSION"
      for i in "${!TASKS[@]}"; do
        task="${TASKS[$i]}"
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        _open_pane "$i" "$SESSION" "$agent" "$desc"
        ok "Launched  ${BCYN}${agent}${R}"
      done

      _config_set "swarm.last_subcommand" "full"
      _config_set "swarm.last_args"       "[]"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info "$SESSION"
      tmux attach -t "$SESSION"
      ;;

    tasks)
      [[ $# -eq 0 ]] && fail "Specify task numbers.  Usage: ai-squad swarm tasks 1 3 5"
      local TASK_NUMS=("$@")
      local SESSION; SESSION="swarm-$(date +%s)"

      header "Swarm  —  Selected Tasks"
      _swarm_require_tmux
      _swarm_require_plan

      mapfile -t ALL_TASKS < <(_extract_tasks)
      [[ ${#ALL_TASKS[@]} -eq 0 ]] && fail "No tasks found in ${PLAN_FILE}"

      info "Session" "$SESSION"
      info "Tasks  " "${TASK_NUMS[*]}"
      printf "\n%b\n" "$HR"

      tmux new-session -d -s "$SESSION"
      local PANE=0 NUM task agent desc

      for NUM in "${TASK_NUMS[@]}"; do
        task=$(printf '%s\n' "${ALL_TASKS[@]}" | grep "Task ${NUM}:" || true)
        if [[ -z "$task" ]]; then
          warn "Task ${NUM} not found in plan — skipping"
          continue
        fi
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        task_row "$NUM" "$agent" "$desc"
        _open_pane "$PANE" "$SESSION" "$agent" "$desc"
        ok "Launched  ${BCYN}${agent}${R}"
        PANE=$((PANE + 1))
      done

      [[ "$PANE" -eq 0 ]] && fail "No valid tasks launched."

      local _args_json
      _args_json="$(printf '"%s",' "${TASK_NUMS[@]}" | sed 's/,$//')"
      _config_set "swarm.last_subcommand" "tasks"
      _config_set "swarm.last_args"       "[${_args_json}]"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info "$SESSION"
      tmux attach -t "$SESSION"
      ;;

    agent)
      [[ $# -lt 2 ]] && fail "Usage: ai-squad swarm agent @agent-name \"prompt\""
      local AGENT="$1"; shift
      local PROMPT="$*"
      local SESSION; SESSION="swarm-$(date +%s)"

      header "Swarm  —  Single Agent"
      _swarm_require_tmux

      info "Agent " "$AGENT"
      info "Prompt" "$PROMPT"

      tmux new-session -d -s "$SESSION"
      tmux send-keys -t "$SESSION" \
        "claude --agent ${AGENT#@} \"${PROMPT}\"" Enter
      ok "Launched ${BCYN}${AGENT}${R}"

      local _agent_args
      _agent_args="$(python3 -c "import json,sys; print(json.dumps(sys.argv[1:]))" \
        "$AGENT" "$PROMPT" 2>/dev/null || echo "[]")"
      _config_set "swarm.last_subcommand" "agent"
      _config_set "swarm.last_args"       "$_agent_args"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info "$SESSION"
      tmux attach -t "$SESSION"
      ;;

    help | *)
      banner
      printf '%b\n\n' "  ${B}USAGE${R}"
      printf '%b\n\n' "    ${D}ai-squad swarm${R} ${B}<subcommand>${R} ${D}[arguments]${R}"
      printf "%b\n" "$HR"
      printf '%b\n' "  ${BCYN}full${R}"
      printf '%b\n' "  ${D}    Launch all unchecked tasks from:${R}"
      printf '  %b    %s%b\n\n' "${D}" "$PLAN_FILE" "${R}"
      printf '%b\n' "  ${BCYN}tasks${R}  ${D}<n> [n...]${R}"
      printf '%b\n\n' "  ${D}    Launch specific task numbers from the plan${R}"
      printf '%b\n' "  ${BCYN}agent${R}  ${D}<@name> <prompt>${R}"
      printf '%b\n\n' "  ${D}    Run a single named agent with a custom prompt${R}"
      printf "%b\n" "$HR"
      printf '%b\n\n' "  ${D}PLAN_FILE env var overrides the default plan path${R}"
      ;;
  esac
}

# ─── help ─────────────────────────────────────────────────────────────────────
cmd_help() {
  header "Help"

  printf '%b\n\n' "  ${B}USAGE${R}"
  printf '%b\n' "    ${D}ai-squad${R} ${B}<command>${R} ${D}[arguments]${R}"

  printf "\n%b\n" "$HR"
  printf '%b\n\n' "  ${B}COMMANDS${R}"

  printf '%b\n' "  ${BCYN}init${R}    ${D}[-y|--yes] [project-name]${R}"
  printf '%b\n' "  ${D}    Scaffold the template into a new or existing directory${R}"
  printf '%b\n\n' "  ${D}    --yes / -y  skip all interactive prompts (for CI)${R}"

  printf '%b\n' "  ${BCYN}labels${R}  ${D}[owner/repo]${R}"
  printf '%b\n\n' "  ${D}    Create GitHub issue labels for the squad pipeline${R}"

  printf '%b\n' "  ${BCYN}swarm${R}   ${D}<full | tasks <n...> | agent <@name> <prompt>>${R}"
  printf '%b\n' "  ${D}    Launch agents in parallel tmux panes (Claude Code only)${R}"
  printf '%b\n\n' "  ${D}    Run: ai-squad swarm help  for details${R}"

  printf "%b\n" "$HR"
  printf '%b\n\n' "  ${B}EXAMPLES${R}"

  printf '%b\n' "  ${D}# New project${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}init${R} my-project"

  printf '%b\n' "  ${D}# Create labels after connecting a remote repo${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}labels${R}"

  printf '%b\n' "  ${D}# Run all plan tasks in parallel${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}swarm full${R}"

  printf '%b\n' "  ${D}# Run specific tasks${R}"
  printf '%b\n\n' "  ${BCYN}ai-squad${R} ${B}swarm tasks${R} 1 3 5"

  printf '%b\n' "  ${D}# Single agent${R}"
  printf '%b\n' "  ${BCYN}ai-squad${R} ${B}swarm agent${R} @dotnet ${D}\"make OrderTests.cs pass\"${R}"

  printf "\n%b\n" "$HR"
  printf '  %bTemplate:  %s%b\n\n' "${D}" "$TEMPLATE_DIR" "${R}"
}

# ─── Dispatch ─────────────────────────────────────────────────────────────────
_config_init
_play_jingle

case "${1:-help}" in
  init)               shift; cmd_init   "$@" ;;
  labels)             shift; cmd_labels "$@" ;;
  swarm)              shift; cmd_swarm  "$@" ;;
  help | -h | --help) cmd_help ;;
  *)
    printf "\n  %b✗%b  Unknown command: %b%s%b\n" "${BRED}" "${R}" "${B}" "$1" "${R}" >&2
    printf '%b\n\n' "  ${D}Run${R} ${B}ai-squad help${R} ${D}for available commands.${R}" >&2
    exit 1
    ;;
esac
