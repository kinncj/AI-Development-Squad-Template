#!/usr/bin/env bash
# ai-squad — AI Development Squad CLI
#
# Install globally:
#   git clone https://github.com/kinncj/AI-Development-Squad-Template.git ~/.ai-squad
#   echo 'export PATH="$HOME/.ai-squad/scripts:$PATH"' >> ~/.zshrc
#   source ~/.zshrc
#
# Usage:
#   ai-squad init   [project-name]          Scaffold template into new or current directory
#   ai-squad labels [owner/repo]            Create GitHub labels in current repo
#   ai-squad swarm  full                    Launch all plan tasks in parallel tmux panes
#   ai-squad swarm  tasks <n> [n...]        Launch specific task numbers
#   ai-squad swarm  agent <@name> <prompt>  Run a single named agent
#   ai-squad help                           Show this help
#
# Copyright (C) 2025 Kinn Coelho Juliao <kinncj@protonmail.com>
# SPDX-License-Identifier: AGPL-3.0-or-later
set -euo pipefail

TOOL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
TEMPLATE_DIR="$TOOL_DIR/template"
PLAN_FILE="${PLAN_FILE:-docs/specs/current/plan.md}"
GLOBAL_CONFIG="$HOME/.ai-squad.json"   # jingle state — once ever, across all projects
CONFIG_FILE="$(pwd)/.ai-squad.json"    # project options — per working directory

# ─── Colour palette ───────────────────────────────────────────────────────────
if [[ -n "${NO_COLOR:-}" || "${TERM:-}" == "dumb" || ! -t 1 ]]; then
  R=''; B=''; D=''; GRN=''; YLW=''; CYN=''
  BGRN=''; BRED=''; BYEL=''; BCYN=''; BMGT=''
  HGRN=''  # hacker green (for banner)
else
  R='\033[0m';    B='\033[1m';    D='\033[2m'
  GRN='\033[0;32m';  YLW='\033[0;33m';  CYN='\033[0;36m'
  BGRN='\033[1;32m'; BRED='\033[1;31m'; BYEL='\033[1;33m'
  BCYN='\033[1;36m'; BMGT='\033[1;35m'
  HGRN='\033[0;32m'  # hacker green
fi

HR="  ${D}$(printf '─%.0s' {1..60})${R}"

# ─── ASCII banner ─────────────────────────────────────────────────────────────
banner() {
  [[ -z "$HGRN" ]] && return
  printf "${HGRN}"
  printf '                                                                    \n'
  printf '   ▄▄▄▄   ▄▄▄▄▄    ▄▄▄▄▄▄▄   ▄▄▄▄▄   ▄▄▄  ▄▄▄   ▄▄▄▄   ▄▄▄▄▄▄   \n'
  printf '  ▄██▀▀██▄  ███    █████▀▀▀ ▄███████▄ ███  ███ ▄██▀▀██▄ ███▀▀██▄  \n'
  printf '  ███  ███  ███     ▀████▄  ███   ███ ███  ███ ███  ███ ███  ███   \n'
  printf '  ███▀▀███  ███       ▀████ ███▄█▄███ ███▄▄███ ███▀▀███ ███  ███   \n'
  printf '  ███  ███ ▄███▄   ███████▀  ▀█████▀  ▀██████▀ ███  ███ ██████▀   \n'
  printf '                          ▀▀                                        \n'
  printf '                                                                    \n'
  printf "${R}"
}

# ─── UI primitives ────────────────────────────────────────────────────────────
header() {
  banner
  printf "  ${B}${BMGT}AI Development Squad${R}  ${D}·${R}  ${B}%s${R}\n" "$1"
  printf "%b\n\n" "$HR"
}

step()    { printf "\n  ${BCYN}›${R}  ${B}%s${R}\n" "$1"; }
ok()      { printf "  ${BGRN}✓${R}  %-32s  ${D}%s${R}\n" "$1" "${2:-}"; }
info()    { printf "  ${CYN}›${R}  %-16s${B}%s${R}\n" "$1" "${2:-}"; }
warn()    { printf "  ${BYEL}!${R}  ${YLW}%s${R}\n" "$1"; }
missing() { printf "  ${BYEL}?${R}  %-32s  ${YLW}not found — %s${R}\n" "$1" "$2"; }
fail()    { printf "\n  ${BRED}✗${R}  ${B}%s${R}\n\n" "$*" >&2; exit 1; }

task_row() {
  local n="$1" agent="$2" desc="$3"
  printf "  ${D}[%2d]${R}  ${BCYN}%-22s${R}  %s\n" "$n" "$agent" "$desc"
}

session_info() {
  local session="$1"
  printf "\n%b\n" "$HR"
  printf "  ${CYN}›${R}  Session   ${B}%s${R}\n" "$session"
  printf "  ${D}›  Detach   Ctrl-b d${R}\n"
  printf "  ${D}›  Kill     tmux kill-session -t %s${R}\n" "$session"
  printf "%b\n\n" "$HR"
}

# ─── Config & jingle ──────────────────────────────────────────────────────────
_config_init() {
  command -v python3 &>/dev/null || return 0
  # Global config — tracks jingle state
  if [[ ! -f "$GLOBAL_CONFIG" ]]; then
    python3 - "$GLOBAL_CONFIG" <<'PYEOF'
import json, sys
with open(sys.argv[1], "w") as f:
    json.dump({"jingle_played": False}, f, indent=2)
    f.write("\n")
PYEOF
  fi
  # Project config — tracks last-used options for this working directory
  if [[ ! -f "$CONFIG_FILE" ]]; then
    python3 - "$CONFIG_FILE" <<'PYEOF'
import json, sys
with open(sys.argv[1], "w") as f:
    json.dump({"init": {}, "labels": {}, "swarm": {}}, f, indent=2)
    f.write("\n")
PYEOF
  fi
}

_config_set() {
  # _config_set <dot.key> <value>
  # JSON literals (true/false/arrays/numbers) are preserved; bare strings stored as-is.
  command -v python3 &>/dev/null || return 0
  [[ -f "$CONFIG_FILE" ]] || return 0
  python3 - "$CONFIG_FILE" "$1" "$2" <<'PYEOF'
import json, sys
path, dotkey, raw = sys.argv[1], sys.argv[2], sys.argv[3]
try:
    with open(path) as f:
        cfg = json.load(f)
except Exception:
    cfg = {}
keys = dotkey.split(".")
d = cfg
for k in keys[:-1]:
    d = d.setdefault(k, {})
try:
    d[keys[-1]] = json.loads(raw)
except Exception:
    d[keys[-1]] = raw
with open(path, "w") as f:
    json.dump(cfg, f, indent=2)
    f.write("\n")
PYEOF
}

_config_get() {
  command -v python3 &>/dev/null || { echo ""; return 0; }
  [[ -f "$CONFIG_FILE" ]] || { echo ""; return 0; }
  python3 - "$CONFIG_FILE" "$1" <<'PYEOF'
import json, sys
try:
    with open(sys.argv[1]) as f:
        v = json.load(f)
    for k in sys.argv[2].split("."):
        v = v[k]
    print(json.dumps(v) if not isinstance(v, str) else v)
except Exception:
    print("")
PYEOF
}

# Read one key from the global config (jingle state lives here).
# Called via $() so heredoc must NOT be used inline — logic lives in the function body.
_global_config_get() {
  command -v python3 &>/dev/null || { echo ""; return 0; }
  [[ -f "$GLOBAL_CONFIG" ]] || { echo ""; return 0; }
  python3 - "$GLOBAL_CONFIG" "$1" <<'PYEOF'
import json, sys
try:
    with open(sys.argv[1]) as f:
        v = json.load(f)
    for k in sys.argv[2].split("."):
        v = v[k]
    print(json.dumps(v) if not isinstance(v, str) else v)
except Exception:
    print("")
PYEOF
}

_global_config_set() {
  command -v python3 &>/dev/null || return 0
  [[ -f "$GLOBAL_CONFIG" ]] || return 0
  python3 - "$GLOBAL_CONFIG" "$1" "$2" <<'PYEOF'
import json, sys
path, dotkey, raw = sys.argv[1], sys.argv[2], sys.argv[3]
try:
    with open(path) as f:
        cfg = json.load(f)
except Exception:
    cfg = {}
keys = dotkey.split(".")
d = cfg
for k in keys[:-1]:
    d = d.setdefault(k, {})
try:
    d[keys[-1]] = json.loads(raw)
except Exception:
    d[keys[-1]] = raw
with open(path, "w") as f:
    json.dump(cfg, f, indent=2)
    f.write("\n")
PYEOF
}

_play_jingle() {
  local jingle="$TOOL_DIR/AI_SQUAD_JINGLE.wav"
  [[ -f "$jingle" ]] || return 0
  [[ "$(_global_config_get jingle_played)" == "true" ]] && return 0
  _global_config_set "jingle_played" "true"   # mark before playing (fire-and-forget)
  # Launch audio in background. Never crash — all errors are silently swallowed.
  {
    if command -v afplay &>/dev/null; then
      # macOS — afplay only handles PCM WAV; use Python3 to unwrap MP3-in-RIFF if needed
      python3 - "$jingle" <<'PYEOF'
import sys, struct, tempfile, os, subprocess

path = sys.argv[1]
with open(path, 'rb') as f:
    data = f.read()

play_path = path
tmp = None

if data[:4] == b'RIFF' and data[8:12] == b'WAVE':
    i = 12
    while i < len(data) - 8:
        cid = data[i:i+4]
        csz = struct.unpack_from('<I', data, i+4)[0]
        if cid == b'data':
            raw = data[i+8:i+8+csz]
            # MP3 sync: ID3 tag or 0xFF 0xEx/0xFF 0xFx frame header
            if raw[:3] == b'ID3' or (len(raw) > 1 and raw[0] == 0xFF and raw[1] & 0xE0 == 0xE0):
                tmp = tempfile.NamedTemporaryFile(suffix='.mp3', delete=False)
                tmp.write(raw)
                tmp.close()
                play_path = tmp.name
            break
        i += 8 + max(csz, 1)

try:
    subprocess.run(['afplay', play_path],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
finally:
    if tmp:
        os.unlink(tmp.name)
PYEOF
    elif command -v paplay         &>/dev/null; then
      # Linux — PulseAudio / PipeWire
      paplay "$jingle"
    elif command -v aplay          &>/dev/null; then
      # Linux — ALSA
      aplay -q "$jingle"
    elif command -v powershell.exe &>/dev/null; then
      # Windows — Git Bash / WSL boundary
      local _win_path
      _win_path="$(command -v cygpath &>/dev/null && cygpath -w "$jingle" 2>/dev/null || echo "$jingle")"
      powershell.exe -NoProfile -Command \
        "(New-Object Media.SoundPlayer '$_win_path').PlaySync()"
    fi
  } >/dev/null 2>&1 &
}

# ─── init ─────────────────────────────────────────────────────────────────────
cmd_init() {
  local TARGET_DIR
  if [[ $# -gt 0 ]]; then
    if [[ "$1" = /* ]]; then
      TARGET_DIR="$1"
    else
      TARGET_DIR="$(pwd)/$1"
    fi
  else
    TARGET_DIR="$(pwd)"
  fi

  header "Initialize Project"
  info "Template" "$TEMPLATE_DIR"
  info "Target  " "$TARGET_DIR"

  if [[ -d "$TARGET_DIR" ]] && [[ -n "$(ls -A "$TARGET_DIR" 2>/dev/null)" ]]; then
    warn "Directory is not empty: $TARGET_DIR"
    printf "  ${BYEL}?${R}  Existing files may be overwritten. Continue? [y/N] "
    read -r _ans
    [[ "$_ans" =~ ^[Yy]$ ]] || fail "Aborted."
  fi

  mkdir -p "$TARGET_DIR"

  step "Checking dependencies"
  local cmd install
  while IFS=: read -r cmd install; do
    if command -v "$cmd" &>/dev/null; then
      ok "$cmd" "$(command -v "$cmd")"
    else
      missing "$cmd" "$install"
    fi
  done <<'DEPS'
git:https://git-scm.com
gh:brew install gh
docker:https://docker.com
node:https://nodejs.org
claude:npm install -g @anthropic-ai/claude-code
DEPS

  step "Copying template"
  rsync -a \
    --exclude='.git' \
    --exclude='node_modules' \
    --exclude='*.log' \
    "$TEMPLATE_DIR/" "$TARGET_DIR/"
  local FILE_COUNT
  FILE_COUNT=$(find "$TARGET_DIR" -type f | wc -l | tr -d ' ')
  ok "Files copied" "$FILE_COUNT files"

  step "Initializing git repository"
  cd "$TARGET_DIR"
  git init -q
  git add -A
  git commit -q -m "chore: initialize from AI Development Squad Template

Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)
Source:    $(basename "$TOOL_DIR")"
  ok "Repository initialized" "commit $(git rev-parse --short HEAD)"
  _config_set "init.last_project" "$(basename "$TARGET_DIR")"
  _config_set "init.last_target"  "$TARGET_DIR"
  _config_set "init.last_run"     "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  if [[ -f "package.json" ]]; then
    step "Installing dependencies"
    npm install --silent
    ok "npm dependencies installed"
    if npx playwright install chromium --quiet 2>/dev/null; then
      ok "Playwright browsers installed"
    else
      warn "Playwright install failed — run: npx playwright install"
    fi
  fi

  printf "\n%b\n" "$HR"
  printf "  ${CYN}?${R}  Bootstrap GitHub labels? ${D}(requires gh auth + remote repo)${R} [y/N] "
  read -r _ans
  if [[ "$_ans" =~ ^[Yy]$ ]]; then
    cmd_labels
  fi

  local PROJECT_NAME
  PROJECT_NAME="$(basename "$TARGET_DIR")"

  printf "\n%b\n" "$HR"
  printf "  ${BGRN}✓${R}  ${B}Squad ready${R}  ${D}→${R}  %s\n\n" "$TARGET_DIR"
  printf "  ${D}Next steps:${R}\n"
  [[ "$TARGET_DIR" != "$(pwd)" ]] && \
    printf "  ${BCYN}›${R}  ${D}cd${R} ${B}%s${R}\n" "$PROJECT_NAME"
  printf "  ${BCYN}›${R}  ${D}gh repo create${R} ${B}%s${R} ${D}--public --push --source=.${R}\n" "$PROJECT_NAME"
  printf "  ${BCYN}›${R}  ${D}claude${R} ${B}/feature${R} ${D}\"your first feature\"${R}\n"
  printf "\n%b\n\n" "$HR"
}

# ─── labels ───────────────────────────────────────────────────────────────────
cmd_labels() {
  header "Bootstrap GitHub Labels"

  local REPO="${1:-}"
  [[ -z "$REPO" ]] && \
    REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || true)
  [[ -z "$REPO" ]] && \
    fail "Could not detect repository.  Pass owner/repo as argument:\n     ai-squad labels owner/repo"

  info "Repository  " "$REPO"

  local CREATED=0 SKIPPED=0

  label() {
    local name="$1" color="$2" desc="$3"
    if gh label create "$name" --repo "$REPO" --color "$color" \
         --description "$desc" --force &>/dev/null; then
      ok "$name" "$desc"
      CREATED=$((CREATED + 1))
    else
      printf "  ${D}–  %-30s  already exists${R}\n" "$name"
      SKIPPED=$((SKIPPED + 1))
    fi
  }

  printf "  ${B}${BCYN}Story & Type${R}\n"
  label "story"        "0075ca" "User story"
  label "bug"          "d73a4a" "Bug report"
  label "must-have"    "e11d48" "MoSCoW: Must have"
  label "should-have"  "f97316" "MoSCoW: Should have"
  label "could-have"   "eab308" "MoSCoW: Could have"
  label "wont-have"    "6b7280" "MoSCoW: Won't have"

  printf "\n  ${B}${BCYN}Pipeline Phases${R}\n"
  label "phase:discover"   "dbeafe" "Phase 1: Discovery"
  label "phase:architect"  "c7d2fe" "Phase 2: Architecture"
  label "phase:plan"       "e9d5ff" "Phase 3: Planning"
  label "phase:infra"      "fce7f3" "Phase 4: Infrastructure"
  label "phase:implement"  "d1fae5" "Phase 5: Implementation"
  label "phase:validate"   "bfdbfe" "Phase 6: Validation"
  label "phase:document"   "fef3c7" "Phase 7: Documentation"
  label "phase:done"       "dcfce7" "Phase 8: Complete"

  printf "\n  ${B}${BCYN}Status${R}\n"
  label "in-progress"      "fde68a" "Work in progress"
  label "blocked"          "fca5a5" "Blocked — needs human intervention"
  label "validated"        "86efac" "All tests passing"
  label "ready-for-review" "a5f3fc" "PR ready for review"

  printf "\n  ${B}${BCYN}TDD State${R}\n"
  label "tdd:red"      "fca5a5" "Failing test written"
  label "tdd:green"    "86efac" "Tests passing"
  label "tdd:refactor" "fde68a" "Refactor phase"

  _config_set "labels.last_repo" "$REPO"
  _config_set "labels.last_run"  "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

  printf "\n%b\n" "$HR"
  printf "  ${BGRN}✓${R}  ${B}Done.${R}  "
  printf "${GRN}%d created${R}  ${D}·${R}  ${D}%d skipped${R}\n" "$CREATED" "$SKIPPED"
  printf "  ${D}›  https://github.com/%s/labels${R}\n\n" "$REPO"
}

# ─── swarm ────────────────────────────────────────────────────────────────────
_swarm_require_tmux() {
  command -v tmux &>/dev/null || \
    fail "tmux not installed.  Install with: brew install tmux"
}

_swarm_require_plan() {
  [[ -f "$PLAN_FILE" ]] || \
    fail "Plan file not found: ${PLAN_FILE}\n     Run /feature first to generate a plan."
}

_extract_tasks() {
  grep -E '^\- \[ \] Task [0-9]+:' "$PLAN_FILE" 2>/dev/null || true
}

_parse_agent() { echo "$1" | grep -oE '@[a-zA-Z0-9_-]+' | head -1; }
_parse_desc()  {
  local task="$1" agent="$2"
  echo "$task" | sed "s/.*${agent}//" | sed 's/^[[:space:]]*//'
}

_open_pane() {
  local idx="$1" session="$2" agent="$3" desc="$4"
  if [[ "$idx" -gt 0 ]]; then
    tmux split-window -t "$session" -h
    tmux select-layout -t "$session" tiled
  fi
  tmux send-keys -t "$session.$idx" \
    "claude --agent ${agent#@} \"${desc}\"" Enter
}

cmd_swarm() {
  local sub="${1:-help}"; shift || true

  case "$sub" in
    full)
      local SESSION="swarm-$(date +%s)"
      header "Swarm  —  Full Plan"
      _swarm_require_tmux
      _swarm_require_plan

      mapfile -t TASKS < <(_extract_tasks)
      [[ ${#TASKS[@]} -eq 0 ]] && \
        fail "No unchecked tasks found in ${PLAN_FILE}\n     All tasks may already be complete."

      info "Plan   " "$PLAN_FILE"
      info "Session" "$SESSION"
      info "Agents " "${#TASKS[@]}"
      printf "\n%b\n" "$HR"

      local i task agent desc
      for i in "${!TASKS[@]}"; do
        task="${TASKS[$i]}"
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        task_row "$((i + 1))" "$agent" "$desc"
      done
      printf "%b\n\n" "$HR"

      tmux new-session -d -s "$SESSION"
      for i in "${!TASKS[@]}"; do
        task="${TASKS[$i]}"
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        _open_pane "$i" "$SESSION" "$agent" "$desc"
        ok "Launched  ${BCYN}${agent}${R}"
      done

      _config_set "swarm.last_subcommand" "full"
      _config_set "swarm.last_args"       "[]"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info "$SESSION"
      tmux attach -t "$SESSION"
      ;;

    tasks)
      [[ $# -eq 0 ]] && fail "Specify task numbers.  Usage: ai-squad swarm tasks 1 3 5"
      local TASK_NUMS=("$@")
      local SESSION="swarm-$(date +%s)"

      header "Swarm  —  Selected Tasks"
      _swarm_require_tmux
      _swarm_require_plan

      mapfile -t ALL_TASKS < <(_extract_tasks)
      [[ ${#ALL_TASKS[@]} -eq 0 ]] && fail "No tasks found in ${PLAN_FILE}"

      info "Session" "$SESSION"
      info "Tasks  " "${TASK_NUMS[*]}"
      printf "\n%b\n" "$HR"

      tmux new-session -d -s "$SESSION"
      local PANE=0 NUM task agent desc

      for NUM in "${TASK_NUMS[@]}"; do
        task=$(printf '%s\n' "${ALL_TASKS[@]}" | grep "Task ${NUM}:" || true)
        if [[ -z "$task" ]]; then
          warn "Task ${NUM} not found in plan — skipping"
          continue
        fi
        agent=$(_parse_agent "$task")
        desc=$(_parse_desc  "$task" "$agent")
        task_row "$NUM" "$agent" "$desc"
        _open_pane "$PANE" "$SESSION" "$agent" "$desc"
        ok "Launched  ${BCYN}${agent}${R}"
        PANE=$((PANE + 1))
      done

      [[ "$PANE" -eq 0 ]] && fail "No valid tasks launched."

      local _args_json
      _args_json="$(printf '"%s",' "${TASK_NUMS[@]}" | sed 's/,$//')"
      _config_set "swarm.last_subcommand" "tasks"
      _config_set "swarm.last_args"       "[${_args_json}]"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info "$SESSION"
      tmux attach -t "$SESSION"
      ;;

    agent)
      [[ $# -lt 2 ]] && fail "Usage: ai-squad swarm agent @agent-name \"prompt\""
      local AGENT="$1"; shift
      local PROMPT="$*"
      local SESSION="swarm-$(date +%s)"

      header "Swarm  —  Single Agent"
      _swarm_require_tmux

      info "Agent " "$AGENT"
      info "Prompt" "$PROMPT"

      tmux new-session -d -s "$SESSION"
      tmux send-keys -t "$SESSION" \
        "claude --agent ${AGENT#@} \"${PROMPT}\"" Enter
      ok "Launched ${BCYN}${AGENT}${R}"

      local _agent_args
      _agent_args="$(python3 -c "import json,sys; print(json.dumps(sys.argv[1:]))" \
        "$AGENT" "$PROMPT" 2>/dev/null || echo "[]")"
      _config_set "swarm.last_subcommand" "agent"
      _config_set "swarm.last_args"       "$_agent_args"
      _config_set "swarm.last_session"    "$SESSION"
      _config_set "swarm.last_run"        "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

      session_info "$SESSION"
      tmux attach -t "$SESSION"
      ;;

    help | *)
      banner
      printf "  ${B}USAGE${R}\n\n"
      printf "    ${D}ai-squad swarm${R} ${B}<subcommand>${R} ${D}[arguments]${R}\n\n"
      printf "%b\n" "$HR"
      printf "  ${BCYN}full${R}\n"
      printf "  ${D}    Launch all unchecked tasks from:${R}\n"
      printf "  ${D}    %s${R}\n\n" "$PLAN_FILE"
      printf "  ${BCYN}tasks${R}  ${D}<n> [n...]${R}\n"
      printf "  ${D}    Launch specific task numbers from the plan${R}\n\n"
      printf "  ${BCYN}agent${R}  ${D}<@name> <prompt>${R}\n"
      printf "  ${D}    Run a single named agent with a custom prompt${R}\n\n"
      printf "%b\n" "$HR"
      printf "  ${D}PLAN_FILE env var overrides the default plan path${R}\n\n"
      ;;
  esac
}

# ─── help ─────────────────────────────────────────────────────────────────────
cmd_help() {
  header "Help"

  printf "  ${B}USAGE${R}\n\n"
  printf "    ${D}ai-squad${R} ${B}<command>${R} ${D}[arguments]${R}\n"

  printf "\n%b\n" "$HR"
  printf "  ${B}COMMANDS${R}\n\n"

  printf "  ${BCYN}init${R}    ${D}[project-name]${R}\n"
  printf "  ${D}    Scaffold the template into a new or existing directory${R}\n\n"

  printf "  ${BCYN}labels${R}  ${D}[owner/repo]${R}\n"
  printf "  ${D}    Create GitHub issue labels for the squad pipeline${R}\n\n"

  printf "  ${BCYN}swarm${R}   ${D}<full | tasks <n...> | agent <@name> <prompt>>${R}\n"
  printf "  ${D}    Launch agents in parallel tmux panes (Claude Code only)${R}\n"
  printf "  ${D}    Run: ai-squad swarm help  for details${R}\n\n"

  printf "%b\n" "$HR"
  printf "  ${B}EXAMPLES${R}\n\n"

  printf "  ${D}# New project${R}\n"
  printf "  ${BCYN}ai-squad${R} ${B}init${R} my-project\n\n"

  printf "  ${D}# Create labels after connecting a remote repo${R}\n"
  printf "  ${BCYN}ai-squad${R} ${B}labels${R}\n\n"

  printf "  ${D}# Run all plan tasks in parallel${R}\n"
  printf "  ${BCYN}ai-squad${R} ${B}swarm full${R}\n\n"

  printf "  ${D}# Run specific tasks${R}\n"
  printf "  ${BCYN}ai-squad${R} ${B}swarm tasks${R} 1 3 5\n\n"

  printf "  ${D}# Single agent${R}\n"
  printf "  ${BCYN}ai-squad${R} ${B}swarm agent${R} @dotnet ${D}\"make OrderTests.cs pass\"${R}\n"

  printf "\n%b\n" "$HR"
  printf "  ${D}Template:  %s${R}\n\n" "$TEMPLATE_DIR"
}

# ─── Dispatch ─────────────────────────────────────────────────────────────────
_config_init
_play_jingle

case "${1:-help}" in
  init)               shift; cmd_init   "$@" ;;
  labels)             shift; cmd_labels "$@" ;;
  swarm)              shift; cmd_swarm  "$@" ;;
  help | -h | --help) cmd_help ;;
  *)
    printf "\n  ${BRED}✗${R}  Unknown command: ${B}%s${R}\n" "$1" >&2
    printf "  ${D}Run${R} ${B}ai-squad help${R} ${D}for available commands.${R}\n\n" >&2
    exit 1
    ;;
esac
